---
layout: post
status: publish
published: true
title: 'PHP: Un fractal de mal dise&ntilde;o'
author:
  display_name: Alpha
  login: Alpha
  email: alphagma@gmail.com
  url: http://www.alphasmanifesto.com/
author_login: Alpha
author_email: alphagma@gmail.com
author_url: http://www.alphasmanifesto.com/
wordpress_id: 4537
wordpress_url: http://blog.alphasmanifesto.com/?p=4537
date: '2013-04-15 21:53:23 +0000'
date_gmt: '2013-04-16 02:53:23 +0000'
categories:
- Technology
tags:
- C#
- desarrollo web
- seguridad
- PHP
- desarrollo
- best practices
- herramientas
- art&iacute;culo
- problemas
- excepciones
- traducci&oacute;n
- lenguaje
- CGI
- Perl
- Zend
- programming
comments:
- id: 8984
  author: Fernando
  author_email: ferrarafer@gmail.com
  author_url: ''
  date: '2013-04-25 21:48:34 +0000'
  date_gmt: '2013-04-26 02:48:34 +0000'
  content: "Bueno, esta lectura es casi el empuj&oacute;n que estaba necesitando para
    dar un paso al costado de PHP y tomar un nuevo camino. Trabajo con PHP desde 2004,
    cuando todo (vista, controlador, modelo) se embebia en un solo archivo, cuando
    hablar de reutilizar c&oacute;digo era casi imposible por lo acoplado que estaba
    y dem&aacute;s cosas que los que han trabajado con PHP deben haber experimentado.
    Siempre estoy tratando de aprender nuevas maneras de desarrollar y es verdad que
    el ciclo de desarrollo que utilizamos cuando usamos PHP nunca parece estar bien,
    siempre me queda esa sensaci&oacute;n de que algo no esta cerrando. Pero igualmente
    sigo adelante, porque la mayor&iacute;a de los errores se van solucionando, los
    ciclos de desarrollo van tomando mejor forma, los frameworks son cada vez mejores
    y por sobre todas las cosas, ya va a ser casi 10 a&ntilde;os que estoy con esto
    y eso es lo que hace muy dif&iacute;cil abandonarlo! En otra disciplina, &iquest;quien
    dejar&iacute;a un know-how de casi 10 a&ntilde;os para pasar a algo nuevo? No
    creo que sean muchos los casos.\r\nCoincido con casi todas las cosa que describe
    el autor en su post, aunque no llego a su nivel de enojo. No me olvido que, por
    mas malo o bueno que sea el lenguaje, he creado aplicaciones de las que clientes
    han estado muy conformes, despu&eacute;s de todo ellos no conocen el como, conocen
    el que, lo que utilizan, que es el producto final, la aplicaci&oacute;n propiamente
    dicha. O a caso, cada una de nuestras creaciones, &iquest;no son como cuadros
    realizados por un artista? &iquest;Importa con que pincel realizaron las obras?\r\nActualmente
    estoy con Zend Framework 2, pero estoy mirando de reojo lenguajes como python
    o ruby para ver que camino tomar, si es que lo tomo. Quizas no haga falta tomar
    otro camino, sino seguir por el mismo e incorporar nuevo armamento :-). Ultimamente,
    estoy pensando que las aplicaciones deben ser cada vez mas constituidas por javascript
    y menos por lenguaje de servidor, por lo que pr&aacute;cticamente, en los sistemas
    web cl&aacute;sicos, se utilizaria el lenguaje del servidor solo para hacer los
    datos persistentes... esto implica otro camino posible a tomar, &iquest;o no?
    :D\r\n\r\nAbrazo,\r\nFernando."
- id: 8986
  author: Alpha
  author_email: alpha@furries.com.ar
  author_url: http://www.alphasmanifesto.com/
  date: '2013-05-03 07:14:04 +0000'
  date_gmt: '2013-05-03 12:14:04 +0000'
  content: |-
    Hola Fer! Perd&oacute;n que no te respondiera antes. Estoy totalmente de acuerdo y agrego algo a favor de tu argumento: nada puede contra la experiencia ya formada. Usando alguna analog&iacute;a, hoy tendremos impresoras 3D que hacen el trabajo f&aacute;cil, pero el David de Miguel &Aacute;ngel se hizo a cinceladas, y sigue siendo maravilloso.

    Tambi&eacute;n como vos, tengo esa sensaci&oacute;n de que siempre <em>algo falta</em>.

    Me gusta tu argumento de que al fin y al cabo, si se logra el resultado, la herramienta no importa. Veo tu punto, y es verdad que cuando el trabajo est&aacute; terminado, la elecci&oacute;n de la herramienta ya es irrelevante. De hecho, sirve s&oacute;lo como retrospectiva porque ya no hay decisiones que tomar.

    Ahora, imaginate que tuvieras los mismos 10 a&ntilde;os de experiencia en un framework/lenguaje que no tuviera estos problemas. &iquest;No ser&iacute;an, seguramente, m&aacute;s simples y productivos y mejores tus proyectos? Yo me inclino a un casi seguro "s&iacute;".

    El nivel de enojo lo hace un poco gracioso, pero estoy de acuerdo con el autor en que algunas cosas son simplemente inaceptables, quiero pensar que muchas son accidentales y no que alguien las haya pensado y dicho "bueno, no importa". Habla mal de nuestra profesi&oacute;n.

    Muy de acuerdo con el cambio hacia el lado del cliente. Hace un tiempo que estoy orientando los desarrollos m&aacute;s al lado del cliente (por supuesto, validaciones del lado del server tambi&eacute;n) y la experiencia para el usuario es algo de otro mundo. Mejor a&uacute;n, me es m&aacute;s f&aacute;cil a mi desarrollarlo.

    &iexcl;Te mando saludos!
- id: 9049
  author: Paul Jim&eacute;nez
  author_email: l0rd_acid@yahoo.com
  author_url: ''
  date: '2013-08-29 14:32:32 +0000'
  date_gmt: '2013-08-29 19:32:32 +0000'
  content: "Saludos amigos.\r\n\r\nYa hab&iacute;a le&iacute;do el art&iacute;culo
    hace tiempo, sin embargo es bueno leerlo en tu propio idioma ya que se entienden
    mejor las ideas, gracias por traducirlo.\r\n\r\nMi experiencia con PHP comienza
    el 2009. empec&eacute; haciendo sitios en PHP y luego sitios web con Zend Framework
    1 y ultimamente en Yii Framework. En 2010 empec&eacute; a interesarme en otros
    lenguajes y use C#/.NET en un par de proyectos personales y al aprender C# fue
    donde me d&iacute; cuenta de lo horrible que es PHP como lenguaje.\r\n\r\nSe que
    la comunidad PHP ha hecho un esfuerzo enorme en proporcionar las herramientas
    para el desarrollo moderno como TDD y desarrollo &aacute;gil, pero considero que
    el problema es el lenguaje como tal y sus falencias/mal dise&ntilde;o, tal y como
    explica el art&iacute;culo.\r\n\r\nUna de las razones por la cual usaba PHP era
    por el hosting barato y la facilidad de hacer deploy al servidor, en la actualidad
    esto ha cambiado mucho, ahora con un simple push en git puedes tener tu aplicaci&oacute;n
    corriendo en servicios como Heroku, Windows Azure etc. Por lo tanto creo que es
    un buen momento para mi en dejar atr&aacute;s PHP y moverme a otros lenguajes
    con un dise&ntilde;o m&aacute;s coherente.\r\n\r\nParticularmente voy a dar el
    paso a C#/.NET porque ya lo conoc&iacute;a de antes y Microsoft ha hecho open
    source muchas de las herramientas para desarrollo web lo cual es excelente porque
    de verdad que son muy profesionales por ejemplo Visual Studio.\r\n\r\nTambi&eacute;n
    estoy aprendiendo node.js para el lado del servidor y Javascript con AngularJS
    para el lado del cliente. Ya que considero, al igual que ustedes, que en las aplicaciones
    web de hoy en d&iacute;a est&aacute;n dando mucha m&aacute;s importancia al lado
    del cliente.\r\n\r\nSaludos y &eacute;xitos."
- id: 9050
  author: Alpha
  author_email: alpha@furries.com.ar
  author_url: http://www.alphasmanifesto.com/
  date: '2013-08-29 14:52:30 +0000'
  date_gmt: '2013-08-29 19:52:30 +0000'
  content: "Hola Paul, much&iacute;simas gracias por tu comentario. Para ser sincero,
    tu respuesta me hizo reflexionar.\r\n\r\nTras traducir el art&iacute;culo (y luego
    de leerlo varias veces, e informarme con otras fuentes), ten&iacute;a una sensaci&oacute;n
    puramente agresiva hacia PHP. Es verdad que tiene falencias muy grandes, es verdad
    que partes de su dise&ntilde;o es terrible, pero ciertamente cumpli&oacute; su
    prop&oacute;sito y por eso es tan popular: fue simple y &uacute;til al momento
    apropiado en las manos apropiadas.\r\n\r\nTu observaci&oacute;n es muy v&aacute;lida:
    hoy tenemos otras opciones y podemos explorarlas sin pagar una sola moneda. &iquest;Quiz&aacute;
    esta sea la &eacute;poca en la que una nueva tendencia se marcar&aacute; como
    el nuevo est&aacute;ndar?\r\n\r\n&iexcl;Gracias! Saludos y &eacute;xitos a t&iacute;
    tambi&eacute;n."
- id: 9072
  author: Vladimir Ramos
  author_email: cibervlacho1972@gmail.com
  author_url: ''
  date: '2013-10-02 14:16:11 +0000'
  date_gmt: '2013-10-02 19:16:11 +0000'
  content: 'En lo personal me pareci&oacute; un desperdicio de tiempo leer este art&iacute;culo.
    Si no te gusta PHP reservatelo a ti mismo y no intentes "convertir" a los dem&aacute;s
    programadores a tus gustos. A mi me encanta Python pero solo para aplicaciones
    de escritorio, ya que para utilizarlo en el desarrollo web hay que forzarlo con
    m&oacute;dulos y configuraciones en Apache o Nginx; mientras que PHP es nativo
    para la web (me encanta), con todo y sus errores e inconsistencias. Solo eres
    uno de tantos Fanboys de las tecnolog&iacute;as "cool" solo porque las usa Google,
    Github, Pinterest, etc, y por lo tanto crees que tambien debes usarlas para estar
    en la onda. Mientras que Python no pueda correr nativamente en un servidor compartido,
    PHP seguir&aacute; siendo utilizado masivamente por la nueva generacion de programadores
    (para tu contrariedad), as&iacute; que te aconsejo que dejes de luchar contra
    la corriente, por que habr&aacute; PHP para rato: http://www.youtube.com/watch?v=_TVdYzlNBO8'
- id: 9073
  author: Vladimir Ramos
  author_email: cibervlacho1972@gmail.com
  author_url: ''
  date: '2013-10-02 14:21:22 +0000'
  date_gmt: '2013-10-02 19:21:22 +0000'
  content: Acabo de darme cuenta que el art&iacute;culo no lo escribiste t&uacute;
    y te dirijo mis disculpas, ya que mis palabras iban dirigidas al autor original.
    Saludos!!!
- id: 9074
  author: Alpha
  author_email: alpha@furries.com.ar
  author_url: http://www.alphasmanifesto.com/
  date: '2013-10-02 14:56:24 +0000'
  date_gmt: '2013-10-02 19:56:24 +0000'
  content: "Disculpas aceptadas. :)\r\n\r\nA favor tuyo, voy a decir que las herramientas,
    por raras que sean, son decisi&oacute;n de cada uno. Si te sientes c&oacute;modo
    con PHP y es tu herramienta en donde eres productivo, adelante. Ese es el punto,
    ser productivo.\r\n\r\nSin embargo, a defensa del autor, estoy de acuerdo con
    que muchos de los problemas que PHP tiene son inaceptables. Va un poco m&aacute;s
    all&aacute; del lenguaje en s&iacute;, va hacia la forma en la que se est&aacute;
    educando a desarrolladores que comienzan a hacer sus webs y aprenden que mezclar
    nomenclaturas, m&oacute;dulos y cosas en un mont&oacute;n de c&oacute;digo es
    algo \"aceptable\". Muchos problemas de seguridad tambi&eacute;n lo son, pero
    cualquier lenguaje los tiene, &iquest;verdad? Lo que es totalmente inaceptable
    es que estos sean por negligencia o ignorancia. No estoy ok con usar una herramienta
    que est&aacute; mal dise&ntilde;ada... no porque la herramienta en s&iacute; sea
    mala, sino porque quiero que sea mejor.\r\n\r\nEn mi mundo ideal, PHP (o sea el
    lenguaje que sea) es un lenguaje bien dise&ntilde;ado. Si solucionaran sus inconsistencias
    con gusto lo abrazar&iacute;a como mi lenguaje de preferencia nuevamente. Para
    ser m&aacute;s claro: no tengo un problema con PHP, tengo un problema con sus
    problemas, y tengo un problema mayor con lo que significa no solucionar esos problemas.\r\n\r\nMe
    encanta de PHP lo permisivo que es, me encanta su libertad de manipulaci&oacute;n
    en memoria y la forma super-compleja o super-simple en la que se pueden hacer
    las cosas. No me gusta que sea inconsistente porque paso m&aacute;s tiempo pensando
    en \"c&oacute;mo era\" m&aacute;s que en resolver mi problema. No me gusta que
    est&eacute; fallado porque el 90% de los desarrolladores lo aceptan as&iacute;
    en lugar de buscar mejorarlo, y creo que esa educaci&oacute;n hace falta.\r\n\r\n&iquest;Crees
    que me equivoco en alguno de estos puntos? Estoy dispuesto a escuchar tu punto
    de vista, pero te pedir&iacute;a dejar agresiones de lado -- defender o atacar
    un lenguaje no nos hace mejores ni peores que nadie. Espero no haber sido ofensivo
    en la respuesta en donde manifiesto mi desacuerdo."
- id: 9100
  author: Presentaci&oacute;n | Rinc&oacute;n de un programador
  author_email: ''
  author_url: http://rincondeunprogramador.wordpress.com/2013/11/04/presentacion/
  date: '2013-11-04 16:51:25 +0000'
  date_gmt: '2013-11-04 21:51:25 +0000'
  content: "[&#8230;] experto buscador de Symfony y PHP en google, me encontr&eacute;
    con entradas tan preocupantes como estas: &#8220;PHP: Un fractal de mal dise&ntilde;o&#8221;&nbsp;o
    &#8220;El preocupante futuro de los formularios Symfony&#8221;. Pero, en vez de
    acabar [&#8230;]"
- id: 9127
  author: Andr&eacute;s Villalonga
  author_email: andervilla@gmail.com
  author_url: ''
  date: '2014-01-25 17:29:45 +0000'
  date_gmt: '2014-01-25 22:29:45 +0000'
  content: Buffff... me vas a perdonar, pero que alguien que no sabe hablar lenguaje
    espa&ntilde;ol correctamente se moleste en intentar traducir un art&iacute;culo
    acerca de un lenguaje de programaci&oacute;n... como qe no me da ninguna garant&iacute;a.
    Primero aprende a hablar correctamente un lenguaje natural y luego m&eacute;tete
    en temas m&aacute;s elaborados. Esa jerga sudaca que manejas... simplemente apesta
    y te descalifica. Vuelve al Amazonas con tu cervatana y deja las cosas del raciocinio
    para la gente de bien, no para los medio-monos arbor&iacute;colas.
- id: 9128
  author: Alpha
  author_email: alpha@furries.com.ar
  author_url: http://www.alphasmanifesto.com/
  date: '2014-01-25 19:46:05 +0000'
  date_gmt: '2014-01-26 00:46:05 +0000'
  content: "Hola Andr&eacute;s.\r\n\r\nTal cual como lo dices, mi espa&ntilde;ol no
    es perfecto, y s&iacute;, admito que mi forma de expresarme se compone de una
    mezcla de dialectos, por razones que no expondr&eacute; aqu&iacute;. Adem&aacute;s,
    mis traducciones suelen dejarse llevar por las expresiones originales en ingl&eacute;s,
    lo cual genera anglicismos extra&ntilde;os, pero creo que a&uacute;n as&iacute;
    logran transmitir el mensaje.\r\n\r\nSi ese no fuera el caso y si mis suposiciones
    sobre mi traducci&oacute;n no fueran ciertas, te invito a enviarme correcciones
    al respecto -- me encantar&iacute;a mejorar la forma en la que el art&iacute;culo
    est&aacute; escrito, y un proof-reader ser&iacute;a muy adecuado.\r\n\r\nSi por
    otro lado, el art&iacute;culo logra transmitir su mensaje de la forma correcta,
    creo que mi objetivo est&aacute; cumplido (pero a&uacute;n as&iacute;, invito
    a correcciones y mejoras).\r\n\r\nSobre el contenido del mismo, mi opini&oacute;n
    est&aacute; expresada m&aacute;s arriba y en varios otros comentarios en este
    mismo art&iacute;culo. Tambi&eacute;n te invito a participar, a favor o en contra,
    con las razones que consideres pertinentes.\r\n\r\n&iexcl;Saludos!"
- id: 9132
  author: Boris Aguilar
  author_email: me@borisaguilar.com
  author_url: http://borisaguilar.com
  date: '2014-01-28 20:53:26 +0000'
  date_gmt: '2014-01-29 01:53:26 +0000'
  content: Pues en lo personal (y me pongo a comentar algo de hace muchos meses xD)
    te puedo decir que el expresar sobre la inconformidad de PHP hace que personas
    que creen que esta bien puedan notar que (por ejemplo) el lenguaje en si, es feo.
    No se si has probado por ejemplo jelastic u openshift o en general cualquier plataforma
    moderna de aplicaciones web que sea escalable... son tan c&oacute;modas para trabajar
    RoR, python, java...
- id: 9133
  author: Alpha
  author_email: alpha@furries.com.ar
  author_url: http://www.alphasmanifesto.com/
  date: '2014-01-31 07:58:12 +0000'
  date_gmt: '2014-01-31 12:58:12 +0000'
  content: "&iexcl;Muy de acuerdo! Las plataformas ayudan mucho, y aunque no he probado
    esas, he tenido alguna experiencia con AppHarbor, Heroku y AWS EB. Creo que si
    bien pueden convertir la historia de implantaci&oacute;n y mantenimiento en algo
    m&aacute;s f&aacute;cil, no quitan (o agregan) al dise&ntilde;o del lenguaje,
    pero s&iacute; a la experiencia del programador. (&iexcl;Que no es poco!)"
- id: 9159
  author: Jos&eacute;
  author_email: maurice_lupin@yahoo.com
  author_url: ''
  date: '2014-03-17 13:40:42 +0000'
  date_gmt: '2014-03-17 18:40:42 +0000'
  content: "La gente de bien no se expresa con xenofobia, racismo. Este comentario
    merece censura. \r\nSaludos."
- id: 9164
  author: Oscar
  author_email: viliomo@gmail.com
  author_url: ''
  date: '2014-04-04 12:11:33 +0000'
  date_gmt: '2014-04-04 17:11:33 +0000'
  content: "No estoy en absoluto de  acuerdo con el fondo del art&iacute;culo. Algunas
    de las razones que expone el art&iacute;culo, simplemente no son ciertas o al
    menos son dudosas (sobre debugs, tratamiento de errores y ecepciones en php ,
    por ejemplo). Una discusi&oacute;n completa me llevar&iacute;a mucho tiempo...
    Me centrar&eacute; en la que creo fundamental:\r\n\r\nNo creo que un buen lenguaje
    deba ser necesariamente predecible, conciso o consistente. Un lenguaje elegante
    quiz&aacute;s, pero para mi un lenguaje enfocado a entornos empresariales  ha
    de tener otras caracter&iacute;sticas fundamentasles:\r\n\r\n- Prototipos e implementaci&oacute;n
    r&aacute;pidos.\r\n- El apoyo a los paradigmas de programaci&oacute;n modernos.\r\n-
    Escalabilidad.\r\n- Rendimiento.\r\n- Interoperabilidad.\r\n- Extensibilidad.\r\n-
    Soporte t&eacute;cnico, comunidad, documentaci&oacute;n.\r\n\r\nEn, entornos web,
    PHP es uno de los mejores. PHP es un lenguje feo, es cierto, pero por una raz&oacute;n:
    compatibilidad con versiones anteriores. PHP es un lenguaje que evoluciona muy
    r&aacute;pidamente y lo hace procurando no crear un punto de ruptura brusco con
    versiones anteriores. Este punto es fundamental en entornos empresariales, aunque
    el precio sea 'afear' el lenguaje."
- id: 9167
  author: Alpha
  author_email: alpha@furries.com.ar
  author_url: http://www.alphasmanifesto.com/
  date: '2014-04-05 16:05:33 +0000'
  date_gmt: '2014-04-05 21:05:33 +0000'
  content: "Allo Oscar.\r\n\r\nAntes que nada, muchas gracias por tu respuesta y la
    forma de expresarla -- da mucho gusto ver que alguien se expresa en desacuerdo
    de una forma civilizada.\r\n\r\nSi es que alg&uacute;n d&iacute;a quisieras exponer
    las razones o las partes del art&iacute;culo que consideres incorrectas o subjetivas,
    con placer me gustar&iacute;a incuirlas o linkearlas desde aqu&iacute; -- me parece
    que el tipo de informaci&oacute;n clara es la que aporta a una buena discusi&oacute;n.\r\n\r\nEstoy
    en desacuerdo contigo en que un lenguaje no necesite ser predecible, conciso o
    consistente. Los considero una herramienta, y mientras m&aacute;s precarias sean
    las herramientas, aunque bien pueden cumplir su trabajo, fallan a su objetivo
    \ primario: ser herramientas &uacute;tiles. Mientras m&aacute;s simple sea una
    herramienta de usar, m&aacute;s &uacute;til se vuelve. Volviendo al ambiente empresarial,
    es importante que un lenguaje sea conciso y predecible: significa que el entrenamiento
    de los desarrolladores es consistente tambi&eacute;n, y que no hay tanta diferencia
    entre un experto y un novato m&aacute;s que la experiencia en s&iacute;, porque
    no hay recovecos oscuros que deban descubrirse.\r\n\r\nEstoy de acuerdo con las
    caracter&iacute;sticas que enumeras para entornos empresariales, pero no considero
    que PHP cumpla con todos ellos (estoy dispuesto a que me digan que estoy equivocado
    y por qu&eacute;). \r\n\r\nParticularmente, no considero que apoye a paradigmas
    de programaci&oacute;n modernos (es claramente procedural, tiene un soporte pobre
    de OOP, y pr&aacute;cticamente nada de programaci&oacute;n funcional* o AOP).\r\n\r\n*
    Soporta el uso de funciones como variables, pero el uso de globales por defecto
    como explica el art&iacute;culo destruye el uso correcto de closures.\r\n\r\nTampoco
    considero que cumpla bien con su interoperabilidad, en donde es tan distinto su
    comportamiento seg&uacute;n la plataforma (falla en abstraer al desarrollador
    del entorno en donde se encuentra).\r\n\r\nConsidero que tiene buen soporte t&eacute;cnico,
    buena comunidad y aceptable documentaci&oacute;n, pero el promedio de esta comunidad
    no est&aacute; enfocada en el buen uso, justamente por muchas de las razones que
    el art&iacute;culo enumera. Claro que esto no lo hace mal lenguaje, &iquest;o
    s&iacute;? Pero sea como sea, hace que no cumpla al 100% este aspecto.\r\n\r\nEstoy
    de acuerdo con que en entornos web es muy bueno, y considero que el punto sobre
    la compatibilidad previa es importante. Creo que estamos de acuerdo en eso &uacute;ltimo,
    pero me parece s&oacute;lo una parte de mucho m&aacute;s que deber&iacute;a cumplir.\r\n\r\nNuevamente,
    &iexcl;muchas gracias por tu respuesta!"
- id: 9174
  author: Ruffles182
  author_email: l.salvador.arreola@gmail.com
  author_url: http://www.jackalope.com.mx
  date: '2014-04-14 16:41:59 +0000'
  date_gmt: '2014-04-14 21:41:59 +0000'
  content: Vayaa! es en serio?, todav&iacute;a queda gente as&iacute;? que lastima
    de comentario...
- id: 10869
  author: 'PHP: Un fractal de mal dise&ntilde;o (o mil y un razones para alejarse
    de PHP)'
  author_email: ''
  author_url: http://www.meneame.net/m/tecnolog√≠a/php-fractal-mal-diseno-mil-razones-alejarse-php
  date: '2014-05-15 00:15:02 +0000'
  date_gmt: '2014-05-15 05:15:02 +0000'
  content: "[&#8230;] PHP: Un fractal de mal dise&ntilde;o (o mil y un razones para
    alejarse de PHP)  [&#8230;]"
- id: 15496
  author: Arturo
  author_email: aguileraarturo1@hotmail.com
  author_url: ''
  date: '2014-06-18 11:28:06 +0000'
  date_gmt: '2014-06-18 16:28:06 +0000'
  content: Pues yo creo que Laravel salva al lenguaje php como tal.
- id: 15588
  author: Alpha
  author_email: alpha@furries.com.ar
  author_url: http://www.alphasmanifesto.com/
  date: '2014-06-21 18:24:20 +0000'
  date_gmt: '2014-06-21 23:24:20 +0000'
  content: Hola Arturo, muchisimas gracias por tu comentario. No ten&iacute;a conocimiento
    del framework Lavarel, pero definitivamente est&aacute; en mi lista a probar ahora.
    &iexcl;Gracias!
- id: 24909
  author: Nestor Javier Leon
  author_email: lg_nestor@hotmail.com
  author_url: ''
  date: '2014-12-21 13:05:50 +0000'
  date_gmt: '2014-12-21 18:05:50 +0000'
  content: Es cierto , yo tenia como primordial aprender .net mvc pero conoci php
    y rapidamente asimile laravel, te puedo decir que es de lo mejor ;) .. y con respecto
    a lo de no hay mucha documentaci&oacute;n, pues no se donde buscaras , en espa&ntilde;ol
    hay poca, pero hay un mar de documentaci&oacute;n para php en poo y en todo lo
    que desees en ingles y alternos ;) . saludos
- id: 24921
  author: Chalo
  author_email: Elmejor@gmail.com
  author_url: ''
  date: '2014-12-28 00:37:50 +0000'
  date_gmt: '2014-12-28 06:37:50 +0000'
  content: Eso es lo lindo del php que no es para cualquier persona es s&oacute;lo
    para aquellas Personas que les apasiona la programaci&oacute;n y no buscan lo
    f&aacute;cil
- id: 25268
  author: Jhonny Samuel Feliz G.
  author_email: jhonnysamuel@gmail.com
  author_url: http://www.informaticabasica.org
  date: '2015-03-09 18:58:13 +0000'
  date_gmt: '2015-03-09 23:58:13 +0000'
  content: No estoy de acuerdo con el autor. Pues porque te guste un lenguaje no significa
    que debas tratar de imponer lo que consideras. La verdad es relativa mi amigo,
    y quizas a ti te funciona mal, sin embargo a otros si les funciona bien. Creo
    que es cuestion de programador y gustos.
- id: 25269
  author: Alpha
  author_email: alphagma@gmail.com
  author_url: http://www.alphasmanifesto.com/
  date: '2015-03-09 19:27:53 +0000'
  date_gmt: '2015-03-10 00:27:53 +0000'
  content: 'Es interesante tu propuesta: el lenguaje, a pesar de inconsistente, es
    de esa forma. &iquest;Es eso necesariamente malo? Yo opino que s&iacute; (y por
    eso estoy de acuerdo con el autor), pero no puedo probarlo objetivamente. Quiz&aacute;
    realmente s&iacute; sea una cuesti&oacute;n de gustos. &iexcl;Gracias!'
- id: 25276
  author: Octavio Razo
  author_email: octavio.razo.verduzco@gmail.com
  author_url: http://webox.org.mx
  date: '2015-03-12 13:15:57 +0000'
  date_gmt: '2015-03-12 18:15:57 +0000'
  content: Hola que tal, es muy interesante la profundidad que tomo el autor para
    describir a detalles el lenguaje y concluir porque es "malo" desde su punto de
    vista. Tengo una pregunta. Cual es el nombre del autor para citarlo en un peque&ntilde;o
    articulo acad&eacute;mico. Gracias
- id: 25277
  author: Alpha
  author_email: alphagma@gmail.com
  author_url: http://www.alphasmanifesto.com/
  date: '2015-03-12 13:45:08 +0000'
  date_gmt: '2015-03-12 18:45:08 +0000'
  content: |-
    Hola! El autor est&aacute; accesible desde <a href="http://eev.ee/" title="Eevee" rel="nofollow">Eevee</a> y usa p&uacute;blicamente ese pseud&oacute;nimo, pero hasta donde s&eacute;, su nombre es Alex Munroe.

    Si fuera posible, &iquest;nos compartir&iacute;as el paper en el cual ser&aacute; citado? Creo que ser&iacute;a interesante para mi y una buena noticia para &eacute;l.

    &iexcl;Saludos!
- id: 25282
  author: Octavio Razo
  author_email: octavio.razo.verduzco@gmail.com
  author_url: http://webox.org.mx
  date: '2015-03-13 19:09:16 +0000'
  date_gmt: '2015-03-14 00:09:16 +0000'
  content: Claro que si, con gusto te mando un correo con el documento ya que lo concluya...
    no es ciertamente sobre critica de PHP, pero es una comparaci&oacute;n de PHP
    vs Go. Gracias por tu respuesta
- id: 25283
  author: Alpha
  author_email: alphagma@gmail.com
  author_url: http://www.alphasmanifesto.com/
  date: '2015-03-13 19:18:30 +0000'
  date_gmt: '2015-03-14 00:18:30 +0000'
  content: "&iexcl;Gracias! Te contactar&eacute; primero por email para que tengas
    mi direcci&oacute;n.\r\n\r\n&iexcl;Saludos y buen fin de semana!"
- id: 25300
  author: Andr&eacute;s Villalonga come verga
  author_email: blabla@bla.com
  author_url: ''
  date: '2015-03-30 14:02:54 +0000'
  date_gmt: '2015-03-30 19:02:54 +0000'
  content: Andr&eacute;s Villalonga, no sos mas idiota porque el d&iacute;a tiene
    24hs.
- id: 25392
  author: 'PHP: ein Fraktal schlechten Designs | Sebins Blog'
  author_email: ''
  author_url: http://sebin-bloggt.net/2015/05/19/php-ein-fraktal-schlechten-designs/
  date: '2015-05-18 17:54:22 +0000'
  date_gmt: '2015-05-18 22:54:22 +0000'
  content: "[&#8230;] sah, dass andere den Artikel auf Spanisch &uuml;bersetzt haben,
    also dachte ich mir, warum sollte es nicht auch eine deutsche &Uuml;bersetzung
    geben? [&#8230;]"
- id: 25931
  author: Roberto
  author_email: robertomiguelgarciaz@gmail.com
  author_url: ''
  date: '2015-11-18 12:27:54 +0000'
  date_gmt: '2015-11-18 18:27:54 +0000'
  content: "Supongo que ning&uacute;n lenguaje es perfecto. Mucha gente echa pestes
    de BASIC y Visual Basic....pero a mi me encantan y me funcionan.\r\nEn cuanto
    a PHP me ha dado problemas como a todos. Lo mismo Javascript, y en general el
    HTML."
- id: 28062
  author: Leonardo Rozas Villegas
  author_email: leonardo.rozas@gmail.com
  author_url: ''
  date: '2016-02-09 10:57:12 +0000'
  date_gmt: '2016-02-09 16:57:12 +0000'
  content: 'Racista, clasista, xen&oacute;fobo... en una palabra: IGNORANTE.'
- id: 34966
  author: Neder Alfonso Fandi&ntilde;o Andrade
  author_email: neafand@gmail.com
  author_url: ''
  date: '2016-10-03 19:27:18 +0000'
  date_gmt: '2016-10-04 00:27:18 +0000'
  content: "Despu&eacute;s de tanto tiempo desde que se escribi&oacute; este articulo,
    apenas le he le&iacute;do el d&iacute;a de hoy, por aquellas cuestiones del ocio,
    Es curioso que el autor usar&aacute; PHP para escribir su blog &laquo;Eso me dice
    Wappalizer&raquo; teniendo en cuenta el odio tan asiduo que expresa por el mismo.\r\n\r\nLa
    verdad me inicie con C++, surfeo entre aguas de Java y sin embargo trabajo con
    PHP y JavaScript. supongo que de este ultimo tambi&eacute;n se comentan horrorosas
    historias. Creo un poco insulso decir que PHP es un lenguaje para no-programadores,
    a&uacute;n quien crea un pseudoc&oacute;digo est&aacute; programando &iexcl;supongo
    que algo de err&oacute;neo debe de haber en el termino!."
- id: 34971
  author: Alpha
  author_email: alphagma@gmail.com
  author_url: http://www.alphasmanifesto.com/
  date: '2016-10-03 22:45:39 +0000'
  date_gmt: '2016-10-04 03:45:39 +0000'
  content: "Hola Neder! Un gusto tener tu respuesta por aqu&iacute;, me alegro de
    que hayas podido finalmente leer el art&iacute;culo. (No te culpo, es algo extenso.)\n\nEl
    autor particularmente usa Pelican que parece estar escrito en Python, eso seg&uacute;n
    el footer de su misma p&aacute;gina (<a href=\"https://eev.ee/blog/2012/04/09/php-a-fractal-of-bad-design/\"
    rel=\"nofollow\">aqu&iacute;</a>). Pero si te refer&iacute;as a este mismo blog,
    s&iacute;, veo la iron&iacute;a. A&uacute;n as&iacute;, recuerda que en este blog
    soy un usuario, no un desarrollador, excepto por el theme y no fue una experiencia
    placentera. Si me preguntaras por qu&eacute; lo uso, mi respuesta ser&iacute;a:
    WordPress me da un buen conjunto de funcionalidades. He estado pensando pasarme
    a Ghost pero a&uacute;n no he encontrado buena motivaci&oacute;n m&aacute;s all&aacute;
    de la curiosidad. \n\nCreo que has dado un punto muy interesante: JavaScript tiene
    muchos de los mismos problemas y a&uacute;n as&iacute; es uno de los lenguajes
    furor de hoy en d&iacute;a. Sin embargo, JavaScript se est&aacute; reformando
    gracias a las nuevas versiones de ECMAScript. Justo hoy le&iacute; una encuesta
    a la comunidad en donde todos est&aacute;n de acuerdo que JS es m&aacute;s complicado
    de lo que deber&iacute;a ser. \n\n&iexcl;Estoy totalmente de acuerdo contigo!
    Algunos lenguajes son pensados elegantemente y otros surgen seg&uacute;n la necesidad.\n\n&iexcl;Gracias!"
- id: 87557
  author: here
  author_email: jada_dixson@yahoo.de
  author_url: http://fr.gravatar.com/oiszeaeokqv
  date: '2018-10-17 10:04:12 +0000'
  date_gmt: '2018-10-17 14:04:12 +0000'
  content: "I have fun with, cause I found just what I was looking for.\r\nYou have
    ended my four day lengthy hunt! God Bless you man. \r\nHave a great day. Bye"
---
<p style="text-align: justify;">Durante mucho tiempo utilic&eacute; PHP, y de hecho, lo sigo utilizando. Sin embargo, siempre sent&iacute; como que algunas cosas no encajaban, y aunque varias veces me propuse aprender un paradigma de PHP de forma seria, nunca lo logr&eacute;. Mucho tiempo despu&eacute;s me enter&eacute; del gran odio generalizado a PHP y los problemas que ha tenido y leyendo esos art&iacute;culos me encontr&eacute; el que voy a traducir a continuaci&oacute;n. <a href="http://me.veekun.com/blog/2012/04/09/php-a-fractal-of-bad-design/">PHP: A fractal of Bad Design</a> es una recopilaci&oacute;n de <a href="http://me.veekun.com/">Eevee</a>, quien muy amablemente accedi&oacute; a que yo lo traduzca. La eleg&iacute; porque es exageradamente detallada y certera.</p>
<p style="text-align: justify;">Deber&iacute;a aclarar que no estoy de acuerdo con todos los puntos mencionados como negativos o siquiera problemas, pero respeto el art&iacute;culo original del autor sin interrupciones.</p>
<p style="text-align: justify;">Sin m&aacute;s, los dejo con el art&iacute;culo. Si pueden leer el original, lo recomiendo.</p>
<p><!--more--></p>
<h2>Prefacio</h2>
<p style="text-align: justify;">Soy quejoso. Me quejo sobre un mont&oacute;n de cosas. Hay mucho en el mundo de la tecnolog&iacute;a que no me gusta, y eso realmente es de esperar -- programar es una disciplina irrisoriamente joven, y ninguno de nosotros tiene la m&aacute;s m&iacute;nima idea de lo que estamos haciendo. Combinen eso con la <a href="http://en.wikipedia.org/wiki/Sturgeon%27s_Law">Ley de Sturgeon</a>, y tengo una vida llena de cosas sobre las que protestar.</p>
<p style="text-align: justify;">Esto no es lo mismo. PHP no es meramente raro de usar, o inapropiado para lo que yo quiero, o sub&oacute;ptimo, o contra mi religi&oacute;n. Puedo decir cualquier tipo de cosas buenas sobre lenguajes que evado, y todo tipo de cosas malas sobre lenguajes que disfruto. Adelante, &iexcl;pregunten! Crea conversaciones interesantes.</p>
<p style="text-align: justify;">PHP es la &uacute;nica excepci&oacute;n. Virtualmente cualquier caracter&iacute;stica de PHP est&aacute; rota de alguna forma. El lenguaje, el framework, el ecosistema, son todos simplemente <strong>malos</strong>. Y no puedo siquiera remarcar ninguna cosa particular porque el da&ntilde;o es demasiado sist&eacute;mico. Cada vez que intento compilar una lista de quejas sobre PHP, me quedo estancado en esta b&uacute;squeda en profundidad descubriendo m&aacute;s y m&aacute;s trivia fatal. (Por tanto, un fractal.)</p>
<p style="text-align: justify;">PHP es una verg&uuml;enza, una mancha en mi oficio. Est&aacute; tan roto, pero tan elogiado por cada amateur emocionado a quien todav&iacute;a le queda aprender algo m&aacute;s, hasta ser exasperante. Tiene m&iacute;seras pocas cualidades redentoras que prefiero olvidarme que existe completamente.</p>
<p style="text-align: justify;">Pero tengo que quitarme esto de encima. As&iacute; que aqu&iacute; va, un &uacute;ltimo intento.</p>
<hr style="width: 75%;" width="75%" />
<h2>Una analog&iacute;a</h2>
<blockquote>
<p style="text-align: justify;">Se me acaba de escapar esto explicando mi frustraci&oacute;n a Mel y ella insisti&oacute; en que lo reprodujera aqu&iacute;:</p>
<p style="text-align: justify;">No puedo siquiera decir qu&eacute; est&aacute; mal con PHP porque -- okay. Imagina que tienes, eh, una caja de herramientas. Un conjunto de herramientas. Se ve bien, con las cosas comunes ah&iacute;.</p>
<p style="text-align: justify;">Sacas un desarmador, y ves que es uno de esos raros de cabecitas triples. Okay, bueno, eso no es demasiado &uacute;til para t&iacute;, pero imaginas que puede servir a veces.</p>
<p style="text-align: justify;">Sacas un martillo, pero disgustado ves que tiene las cu&ntilde;as de ambos lados. De todos modos, a&uacute;n sirve, me refiero a que puedes golpear los clavos con la parte del centro de la cabeza sosteni&eacute;ndolo de lado.</p>
<p style="text-align: justify;">Sacas una de las pinzas, pero no tienen esas superficies &aacute;speras; es plana y suave. Eso es menos &uacute;til, pero a&uacute;n ayuda a girar las tuercas, as&iacute; que de todos modos est&aacute; bien.</p>
<p style="text-align: justify;">Y as&iacute; sigues. Cada cosa en la caja es de alguna forma rara y estrafalaria, pero quiz&aacute; no tanto como para hacerla in&uacute;til. Y no hay ning&uacute;n problema claro con el conjunto como un todo; todav&iacute;a tiene todas las herramientas.</p>
<p style="text-align: justify;">Ahora imagina que conoces a millones de carpinteros usando esta herramienta que te dicen "hey bueno, &iquest;cu&aacute;l es el problema con estas herramientas? &iexcl;Es todo lo que he usado y han funcionado bien!" Y los carpinteros te muestran las csasas que han hecho, en donde cada habitaci&oacute;n es un pent&aacute;gono y el techo est&aacute; de cabeza. Y golpeas en la puerta principal y todo colapsa hacia adentro y todos te gritan por romper su puerta.</p>
<p style="text-align: justify;">Eso es lo que est&aacute; mal con PHP.</p>
</blockquote>
<hr style="width: 75%;" width="75%" />
<h2>Postura</h2>
<p style="text-align: justify;">Yo aseguro que las siguientes cualidades son&nbsp;<em>importantes</em> para hacer a un lenguaje productivo y &uacute;til, y PHP las viola desenfrenadamente. Si no est&aacute;s de acuerdo en que estas son cruciales, bueno, no puedo imaginar que estaremos de acuerdo en nada.</p>
<ul style="text-align: justify;">
<li>Un lenguaje debe ser&nbsp;<strong>predecible</strong>. Es un medio para expresar ideas humanas y tener a una computadora ejecut&aacute;ndolas, por lo que es cr&iacute;tico que la comprensi&oacute;n humana de un programa sea de hecho correcta.</li>
<li>Un lenguaje debe ser <strong>consistente</strong>. Cosas similares se ven similares, cosas diferentes se ven diferentes. Conocer parte del lenguaje deber&iacute;a ayudar en aprender y comprender el resto.</li>
<li>Un lenguaje debe ser&nbsp;<strong>conciso</strong>. Los nuevos lenguajes existen para reducir el modelo est&aacute;ndar de otros lenguajes viejos. (Todos&nbsp;<em>podr&iacute;amos</em> escribir en c&oacute;digo m&aacute;quina.) Un lenguaje debe entonces buscar introducir nuevos modelos est&aacute;ndares propios.</li>
<li>Un lenguaje debe ser&nbsp;<strong>confiable</strong>. Los lenguajes son herramientas para resolver problemas; deber&iacute;an minimizar cualquier nuevo problema que introducen. Cualquier "gotchas" son distracciones masivas.</li>
<li>Un lenguaje debe ser <strong>debuggeable</strong>. Cuando algo sale mal, el programador&nbsp;<em>debe</em> arreglarlo, y necesitamos toda la ayuda que podamos obtener.</li>
</ul>
<p style="text-align: justify;">Mi posici&oacute;n es por tanto:</p>
<ul style="text-align: justify;">
<li>PHP est&aacute; lleno de sorpresas: <span style="font-family: 'courier new', courier;">mysql_real_escape_string</span>, <span style="font-family: 'courier new', courier;">E_ALL</span></li>
<li>PHP es inconsistente: <span style="font-family: 'courier new', courier;">strpos</span>, <span style="font-family: 'courier new', courier;">str_rot13</span></li>
<li>PHP requiere de un modelo est&aacute;ndar: checkeo alrededor de llamadas a APIs de C, <span style="font-family: 'courier new', courier;">===</span></li>
<li>PHP es descascarado: <span style="font-family: 'courier new', courier;">===</span>, <span style="font-family: 'courier new', courier;">foreach ($foo as &amp;$bar)</span></li>
<li>PHP es opaco: no hay stack traces por default o for fatales, el reporte de errores es complejo</li>
</ul>
<p style="text-align: justify;">No puedo proveer un p&aacute;rrafo de comentario para cada problema explicando por qu&eacute; falla en estas categor&iacute;as, o esto ser&iacute;a interminable. Espero que el lector, digamos, piense.</p>
<hr style="width: 75%;" width="75%" />
<h2>No comentes con estas cosas</h2>
<p style="text-align: justify;">He estado&nbsp;<em>mucho</em> en discusiones sobre PHP. Escucho muchos argumentos muy gen&eacute;ricos que est&aacute;n solo dise&ntilde;ados para detener la conversaci&oacute;n inmediatamente. No me vengas con estos por favor. :(</p>
<ul>
<li style="text-align: justify;">No me digan que "los buenos programadores pueden escribir buen c&oacute;digo en cualquier lenguaje", o que los malos programadores bla, bla, bla. Eso no significa nada. Un buen carpintero&nbsp;<em>puede&nbsp;</em>martillar un clavo con una roca o un martillo, pero &iquest;cu&aacute;ntos carpinteros ves martillando con rocas? Parte de lo que hace a un buen desarrollador es la habilidad para&nbsp;<em>elegir</em> las herramientas con las que trabaja mejor.</li>
<li style="text-align: justify;">No me digas que es responsabilidad de los programadores memorizar mil excepciones y comportamientos extra&ntilde;os. S&iacute;, esto es necesario en cualquier sistema, porque las computadoras apestan. Eso no significa que no hay un l&iacute;mite superior por cu&aacute;nto payaseo es permitido en un sistema. PHP no es nada&nbsp;<em>sino</em> excepciones, y no est&aacute; bien cuando pelear con el lenguaje de hecho toma m&aacute;s esfuerzo que escribir tu programa. Mis herramientas no deber&iacute;an crear m&aacute;s trabajo neto para que yo haga.</li>
<li style="text-align: justify;">No me digas que "as&iacute; es c&oacute;mo funciona la API de C". &iquest;Cu&aacute;l es el punto de usar un lenguaje de alto nivel si todo lo que provee son utilidades de cadenas y un mont&oacute;n de wrappers de C textuales? &iexcl;S&oacute;lo escriban C en ese caso! Aqu&iacute;, incluso hay una <a href="http://www.boutell.com/cgic/">librer&iacute;a CGI</a> para &eacute;l.</li>
<li style="text-align: justify;">No me digas que "eso es lo que te pasa por hacer cosas raras". Si dos caracter&iacute;sticas existen, alg&uacute;n d&iacute;a, alguien va a encontrar una raz&oacute;n para usarlas juntas. Y nuevamente, esto no es C; no hay especificaciones, no hay necesidad para "comportamiento indeterminado".</li>
<li style="text-align: justify;">No me digas que Facebook y Wikipedia est&aacute;n construidos en PHP. &iexcl;Ya lo s&eacute;! Podr&iacute;an estar tambi&eacute;n escritos en Brainfuck, pero mientras haya gente inteligente todav&iacute;a peleando con las cosas, ellos&nbsp;<em>pueden</em> sobreponerse a los problemas con la plataforma. Por todo lo que sabemos, el tiempo de desarrollo podr&iacute;a haber sido duplicado o reducido a la mitad si huberan sido escritos en otro lenguaje; estos datos de por s&iacute; no significan nada.</li>
<li style="text-align: justify;">Idealmente, &iexcl;no me digas nada! Este es mi gran intento; si esta lista no hiere tu opini&oacute;n de PHP,&nbsp;<em>nada</em> nunca lo har&aacute;, as&iacute; que deja de discutir con un tipo en internet y ve a hacer un sitio cool en tiempo r&eacute;cord para demostrar que estoy equivocado. :)</li>
</ul>
<p style="text-align: justify;">Observaci&oacute;n al margen: me encaaaaaaaaanta Python. Tambi&eacute;n podr&iacute;a felizmente hablarte lo que quieras quej&aacute;ndome sobre &eacute;l, si realmente quisieras que lo haga. No aseguro que sea&nbsp;<em>perfecto</em>; simplemente he balanceado sus beneficios contra sus problemas y he conclu&iacute;do que es lo mejor que se ajusta a las cosas que quiero hacer.</p>
<p style="text-align: justify;">Y nunca he conocido a un programador de PHP que puede hacer lo mismo con PHP. Pero me he encontrado con muchos que son r&aacute;pidos para disculparse por cualquier cosa y todo lo que PHP hace. Esa mentalidad es terrible.</p>
<hr style="width: 75%;" width="75%" />
<h2>PHP</h2>
<h3>Lenguaje central</h3>
<p style="text-align: justify;">CPAN ha sido llamada la "librer&iacute;a est&aacute;ndar de Perl". Eso no dice mucho sobre la librer&iacute;a est&aacute;ndar de Perl, pero deja ver el punto de que un n&uacute;cleo s&oacute;lido puede construir cosas grandes.</p>
<h4>Filosof&iacute;a</h4>
<ul>
<li style="text-align: justify;">PHP fue originalmente dise&ntilde;ado expl&iacute;citamente para no-programadores (y, leyendo entre l&iacute;neas, no-programas); y no ha escapado sus ra&iacute;ces bien. Una cita escogida desde la <a href="http://www.php.net/manual/phpfi2.php#overload">documentaci&oacute;n de PHP 2.0</a>, respecto de <span style="font-family: 'courier new', courier;">+</span> y amigos haciendo conversi&oacute;n de tipos:</li>
</ul>
<blockquote>
<p style="text-align: justify;">Una vez que comienzas a tener operadores separados para cada tipo, comienzas a hacer el lenguaje mucho m&aacute;s complejo. i.e., no puedes usar '==' para stings [sic], ahora usar&iacute;as 'eq'. No veo el punto, especialmente para algo como PHP en donde la mayor&iacute;a de los scripts ser&aacute;n generalmente simples y en muchos casos escrito por no-programadores que quieren un lenguaje con una sintaxis l&oacute;gica b&aacute;sica y no tiene una curva de aprendizaje muy elevada.</p>
</blockquote>
<ul style="text-align: justify;">
<li>PHP est&aacute; construido para mantenerse resoplando a todo costo. Cuando se encuentra con la opci&oacute;n de hacer algo sin sentido o abortar con un error, har&aacute; algo sin sentido. Cualquier cosa es mejor que nada.</li>
<li>No hay una filosof&iacute;a de dise&ntilde;o clara. El antiguo PHP fue inspirado en Perl; la gran librer&iacute;a est&aacute;ndar stdlib con par&aacute;metros "out" es de C; las partes orientadas a objetos fueron dise&ntilde;adas como C++ y Java.</li>
<li>PHP toma grandes cantidades de inspiraci&oacute;n de otros lenguajes, pero a&uacute;n as&iacute; logra ser incomprensible para aquellos que&nbsp;<em>conocen</em> esos lenguajes. <span style="font-family: 'courier new', courier;">(int)</span> se ve como C, pero <span style="font-family: 'courier new', courier;">int</span> no existe. Los namespaces usan <span style="font-family: 'courier new', courier;">\</span>. La nueva sintaxis de los arrays resulta en <span style="font-family: 'courier new', courier;">[key => value]</span>, &uacute;nico entre cualquier lenguaje con hashes literales.</li>
<li>El tipado d&eacute;bil (i.e., conversi&oacute;n silenciosa autom&aacute;tica entre strings/n&uacute;meros/et al) es tan complejo que cualquier esfuerzo menor de programaci&oacute;n ahorrado no lo vale.</li>
<li>Funcionalidad nueva peque&ntilde;a es implementada como sintaxis nueva; mucho de lo que est&aacute; hecho con funciones o cosas que parecen como funciones. Excepto por el soporte de clases, que mereci&oacute; un mont&oacute;n de nuevos operadores y keywords.</li>
<li>Algunos de los problemas listados en esta p&aacute;gina tienen soluciones de primera mano -- si est&aacute;s dispuesto a pagarle a Zend por arreglos para su lenguaje de programaci&oacute;n open-source.</li>
<li>Hay mucha acci&oacute;n a distancia. Considera este c&oacute;digo, tomado de los documentos de PHP en alg&uacute;n lado.<br />
<span style="font-family: 'courier new', courier;">@fopen('http://example.com/archivo-no-existente', 'r');<br />
</span><br />
&iquest;Qu&eacute; har&aacute;?</p>
<ul>
<li>Si PHP fue compilador con <span style="font-family: 'courier new', courier;">--disable-url-fopen-wrapper</span>, no funcionar&aacute;. (La documentaci&oacute;n no dice que significa "no funcionar&aacute;"; &iquest;devuelve null, tira una excepci&oacute;n?)</li>
<li>Si <span style="font-family: 'courier new', courier;">allow_url_fopen</span> est&aacute; deshabilitado en php.ini, a&uacute;n no funcionar&aacute;. (&iquest;C&oacute;mo? Ni idea.)</li>
<li>Dado el <span style="font-family: 'courier new', courier;">@</span>, el warning sobre el archivo no existente no ser&aacute; mostrado.</li>
<li>Pero ser&aacute; mostrado si <span style="font-family: 'courier new', courier;">scream.enabled</span> est&aacute; seteado en php.ini.</li>
<li>Pero no si el <span style="font-family: 'courier new', courier;">error_reporting</span> correcto no est&aacute; seteado.</li>
<li>Si&nbsp;<em>es</em> mostrado, a donde va exactamente depende de <span style="font-family: 'courier new', courier;">display_errors</span>, nuevamente en php.ini. O <span style="font-family: 'courier new', courier;">ini_set</span>.</li>
</ul>
</li>
<li>(continuaci&oacute;n del punto anterior)<br />
No puedo saber c&oacute;mo esta inocua llamada &nbsp;a funci&oacute;n se comportar&aacute; sin consultar seteos de compilaci&oacute;n, configuraciones a nivel servidor y configuraciones hechas en mi programa. Y todo esto es comportamiento <em>intr&iacute;nseco</em>.</li>
<li>El lenguaje est&aacute; lleno de estado global impl&iacute;cito. <span style="font-family: 'courier new', courier;">mbstring</span> usa un set de caracteres global. <span style="font-family: 'courier new', courier;">func_get_arg</span> y compa&ntilde;&iacute;a se ven como funciones regulares, pero operan en la funci&oacute;n que se ejecuta actualmente. Manejo de errores y excepciones tienen defaults globales. <span style="font-family: 'courier new', courier;">register_tick_function</span> setea a una funci&oacute;n global para ser ejecutada en cada tick -- &iexcl;&iquest;qu&eacute;?!</li>
<li>No hay soporte de threading en absoluto. (No es sorprendente, dado lo anterior.) Combinado con la falta de un <span style="font-family: 'courier new', courier;">fork</span> incorporado (mencionado abajo), esto hace que la programaci&oacute;n paralela sea extremedamente dif&iacute;cil.</li>
<li>Partes de PHP est&aacute;n pr&aacute;cticamente&nbsp;<em>dise&ntilde;adas&nbsp;</em>para producir c&oacute;digo con bugs.
<ul>
<li><span style="font-family: 'courier new', courier;">json_decode</span> devuelve null para entradas inv&aacute;lidas, aunque null es tambi&eacute;n un objeto perfectamente v&aacute;lido para ser decodificado como JSON -- esta funci&oacute;n es&nbsp;<em>completamente poco fiable</em> a menos que tambi&eacute;n llames a <span style="font-family: 'courier new', courier;">json_last_error</span> cada vez que la uses.</li>
<li><span style="font-family: 'courier new', courier;">array_search</span>, <span style="font-family: 'courier new', courier;">strpos</span> y funciones similares devuelven <span style="font-family: 'courier new', courier;">0</span> si encuentra la aguja en la posici&oacute;n cero, pero falso si no la encuentran en absoluto.</li>
</ul>
</li>
<li>(continuaci&oacute;n del punto anterior)<br />
Perm&iacute;teme expandirme en esa &uacute;ltima parte un poco.<br />
En C, las funciones como <span style="font-family: 'courier new', courier;">strpos</span> devuelven <span style="font-family: 'courier new', courier;">-1</span> si el item no es encontrado. Si no checkeas por ese caso e intentas usarlo como &iacute;ndice, llegar&aacute;s a memoria basura y tu programa explotar&aacute;. (Probablemente. Es C. &iquest;Qui&eacute;n demonios sabe? Estoy seguro de que hay herramientas para esto, como menos.)<br />
En, digamos, Python, el m&eacute;todo equivalente, <span style="font-family: 'courier new', courier;">.index</span> arrojar&aacute;n una excepci&oacute;n &nbsp;si el &iacute;tem no es encontrado. Si no checkeas por ese caso, tu programa explotar&aacute;.<br />
En PHP, estas funciones devuelven falso. Si usas <span style="font-family: 'courier new', courier;">FALSE</span> como &iacute;ndice, o haces casi cualquier cosa con &eacute;l excepto comparar con <span style="font-family: 'courier new', courier;">===</span>, PHP silenciosamente lo convertir&aacute; a <span style="font-family: 'courier new', courier;">0</span> para t&iacute;. Tu programa no explotar&aacute;; en cambio, <em>har&aacute; lo equivocado sin aviso</em>, a menos que recuerdes incluir el c&oacute;digo est&aacute;ndar alrededor de cada lugar en donde uses <span style="font-family: 'courier new', courier;">strpos</span> y ciertas otras funciones.<br />
&iexcl;Esto est&aacute; mal! Los lenguajes de programaci&oacute;n son herramientas; se supone que deben trabajar <em>conmigo</em>. Aqu&iacute;, PHP ha activamente creado una sutil trampa para que yo caiga en ella, y yo debo estar atento incluso con cosas mundanas como operaciones de cadena y comparaciones de igualdad. PHP es <em>un campo minado</em>.</li>
</ul>
<p style="text-align: justify;">He escuchado una buena cantidad de historias sobre PHP y <a href="http://en.wikiquote.org/wiki/Rasmus_Lerdorf">sus desarrolladores</a> de muchos lugares. Estas son de la gente que ha trabajado en <a href="http://www.reddit.com/r/lolphp/comments/qeq7k/php_540_ships_with_82_failing_tests_in_the_suite/">el n&uacute;cleo de PHP</a>, <a href="http://perlbuzz.com/2008/09/optimizing-for-the-developer-not-the-user-php-misses-again.html">ha debuggeado</a> el n&uacute;cleo de PHP, interactuado con los desarrolladores del n&uacute;cleo. Ni una sola historia ha sido un elogio.</p>
<p style="text-align: justify;">Entonces debo poner esto aqu&iacute;, porque vale la pena repetirlo: PHP es una comunidad de amateurs. Muy poca gente dise&ntilde;&aacute;ndolo, trabajando en &eacute;l o escribiendo c&oacute;digo en &eacute;l parece saber lo que est&aacute;n haciendo. (Oh, querido lector, &iexcl;<em>t&uacute;</em> eres por supuesto una rara excepci&oacute;n!) Ellos que <em>s&iacute;</em> logran tener una pista tienden a alejarse a otras plataformas, reduciendo la competencia promedio del todo. Este, aqu&iacute; mismo, es el mayor problema con PHP: es absolutamente el ciego guiando a los ciegos.</p>
<p style="text-align: justify;">Okay, de vuelta a los hechos.</p>
<h4>Operadores</h4>
<ul>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">==&nbsp;</span>es in&uacute;til
<ul>
<li>No es transitivo. &nbsp;<span style="font-family: 'courier new', courier;">"foo" == TRUE</span>, y <span style="font-family: 'courier new', courier;">"foo" == 0</span>... pero, por supuesto, <span style="font-family: 'courier new', courier;">TRUE != 0</span>.</li>
<li><span style="font-family: 'courier new', courier;">==</span> convierte a n&uacute;meros cuando es posible (<span style="font-family: 'courier new', courier;">123 == "123foo"</span>... aunque <span style="font-family: 'courier new', courier;">"123" != "123foo"</span>), lo que significa que convierte a punto flotante cuando es posible. Entonces, cadenas largas hexadecimales (como por ejemplo, digamos, hashes de passwords) pueden ocasionalmente <a href="http://phpsadness.com/sad/47">compararse a true cuando no lo son</a>. Ni JavaScript hace esto.</li>
<li>Por la misma raz&oacute;n, <span style="font-family: 'courier new', courier;">"6" == " 6 "</span>, <span style="font-family: 'courier new', courier;">"4.2" == "4.20"</span>, y <span style="font-family: 'courier new', courier;">"133" == "0133"</span>. Pero nota que <span style="font-family: 'courier new', courier;">133 != 0133</span> porque <span style="font-family: 'courier new', courier;">0133</span> es octal. &iexcl;<em>Pero</em> <span style="font-family: 'courier new', courier;">"0x10" == "16"</span> y <span style="font-family: 'courier new', courier;">"1e3" == "1000"</span>!</li>
<li><span style="font-family: 'courier new', courier;">===</span> compara valores y tipo... excepto con objectos, &iexcl;en donde <span style="font-family: 'courier new', courier;">===</span> es solamente verdadero si ambos operandos son el mismo objeto! Para objetos <span style="font-family: 'courier new', courier;">==</span> compara ambos valores (de cada atributo) y tipo, que es lo que <span style="font-family: 'courier new', courier;">===</span> hace para cualquier otro tipo. <a href="http://developers.slashdot.org/comments.pl?sid=204433&amp;cid=16703529">&iquest;Qu&eacute;?</a></li>
</ul>
</li>
<li style="text-align: justify;">La comparaci&oacute;n no es mucho mejor.
<ul>
<li>Ni siquiera es consistente: <span style="font-family: 'courier new', courier;">NULL < -1</span>, y <span style="font-family: 'courier new', courier;">NULL == 0</span>. El ordenamiento es por tanto no determin&iacute;stico; depende del orden en el que los algoritmos de ordenaci&oacute;n comparan los elementos.</li>
<li>Los operadores de comparaci&oacute;n tratan de ordenar arrays de dos maneras distintas: primero por tama&ntilde;o, luego por&nbsp;<em>elementos</em>. Sin embargo, si tienen&nbsp;el mismo n&uacute;mero de elementos, pero&nbsp;<em>diferente</em> conjunto de claves, son incomparables.</li>
<li>Los objetos se comparan como mayores a cualquier otra cosa... excepto otros objetos, en donde nunca son menores o mayores.</li>
<li>Para un <span style="font-family: 'courier new', courier;">==</span> con tipado m&aacute;s seguro, tenemos <span style="font-family: 'courier new', courier;">===</span>. Para un <span style="font-family: 'courier new', courier;"><</span> con tipado m&aacute;s seguro tenemos... nada. <span style="font-family: 'courier new', courier;">"123" < "0124"</span>, no importa lo que hagas. El casting tampoco ayuda.</li>
</ul>
</li>
<li style="text-align: justify;">A pesar de la locura de m&aacute;s arriba, y el rechazo expl&iacute;cito de los pares de operadores num&eacute;ricos y de cadena de Perl, PHP no sobrecarga <span style="font-family: 'courier new', courier;">+</span>. <span style="font-family: 'courier new', courier;">+</span> es siempre adici&oacute;n y <span style="font-family: 'courier new', courier;">.</span> es siempre concatenaci&oacute;n.</li>
<li style="text-align: justify;">El operador de indexado <span style="font-family: 'courier new', courier;">[]</span> tambi&eacute;n puede ser escrito <span style="font-family: 'courier new', courier;">{}</span>.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">[]</span> puede ser usado en cualquier variable, no s&oacute;lo cadenas y arrays. Devuelve null y no arroja ning&uacute;n warning.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">[]</span> no puede partir/rebanar, s&oacute;lo devuelve elementos individuales.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">foo()[0]</span> es un error de sintaxis. (Arreglado en PHP 5.4.)</li>
<li style="text-align: justify;">A diferencia de (&iexcl;literalmente!) cualquier otro lenguaje con un operador similar, ?: es asociativo&nbsp;<em>a izquierda</em>. Entonces esto:<br />
<span style="font-family: 'courier new', courier;">$arg = 'T';</span><br />
<span style="font-family: 'courier new', courier;">$vehicle = ( ( $arg == 'B' ) ? 'bus' :<br />
( $arg == 'A' ) ? 'airplane' :<br />
( $arg == 'T' ) ? 'train' :<br />
( $arg == 'C' ) ? 'car' :<br />
( $arg == 'H' ) ? 'horse' :<br />
'feet');<br />
echo $vehicle<br />
</span>imprime <span style="font-family: 'courier new', courier;">horse</span>.</li>
</ul>
<h4>Variables</h4>
<ul>
<li style="text-align: justify;">No hay forma de declarar una variable. Las variables que no existen son creadas con un valor nulo cuando son usadas por primera vez.</li>
<li style="text-align: justify;">Las variables globales necesitan una declaraci&oacute;n <span style="font-family: 'courier new', courier;">global</span> antes de ser usadas. Esta es una consecuencia natural de lo anterior, por lo que ser&iacute;a perfectamente razonable, pero las variables globales no se pueden siqueira&nbsp;<em>leer</em> sin una declaraci&oacute;n expl&iacute;cita -- PHP en su lugar silenciosamente crear&aacute; una variable local con el mismo nombre. No estoy consciente de otro lenguaje con problemas de &aacute;mbitos similares.</li>
<li style="text-align: justify;">No hay referencias. Lo que PHP llama referencias son en realidad alias; no hay nada que sea un paso atr&aacute;s, como las referencias de Perl, y no hay identidad de pasaje-por-objeto como en Python.</li>
<li style="text-align: justify;">El referenciamiento infecta una variable como ninguna otra cosa en el lenguaje. PHP es de tipado din&aacute;mico, por lo que las variables generalmente no tienen tipo... excepto las referencias, que adornan definiciones de funciones, sintaxis de las variables, y asignaciones. Una vez que una variable ha sido convertida en referencia (que puede pasar en cualquier lugar), est&aacute; atorada como referencia. No hay una forma obvia de detectar esto y de-referenciarla requiere destruir la variable completamente.</li>
<li style="text-align: justify;">Okay, ment&iacute;. Hay "<a href="http://www.php.net/manual/en/book.spl-types.php">Tipos SPL</a>" que tambi&eacute;n infectan a las variables: <span style="font-family: 'courier new', courier;">$x = new SplBool(true); $x = "foo";</span> fallar&aacute;. Es como un tipado est&aacute;tico.</li>
<li style="text-align: justify;">Una referencia puede ser hecha a una key que no existe en una variable no definida (que se convierte en un array). Usar un array no existente por lo general genera un aviso, pero este no.</li>
<li style="text-align: justify;">Las constantes son definidas por una llamada a una funci&oacute;n que toman una cadena; antes de eso, no exist&iacute;an. (Esto podr&iacute;a de hecho ser una copia del comportamiento de <span style="font-family: 'courier new', courier;">use constant</span> de Perl.)</li>
<li style="text-align: justify;">Los nombres de las variables son sensibles a may&uacute;sculas y min&uacute;sculas. Las funciones y nombres de clases no lo son. Esto incluye nombres de m&eacute;todos, que hace que camelCase sea una elecci&oacute;n extra&ntilde;a para la nomenclatura.</li>
</ul>
<h4>Conceptos</h4>
<ul>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">array()</span> y otra docena de conceptos no son funciones. <span style="font-family: 'courier new', courier;">array</span> por cuenta propia no significa nada. <span style="font-family: 'courier new', courier;">$func = "array"; $func();</span> no funciona.</li>
<li style="text-align: justify;">El desempaquetado de arrays puede hacerse con la operaci&oacute;n <span style="font-family: 'courier new', courier;">list($a, $b) = ...</span>. <span style="font-family: 'courier new', courier;">list()</span> es sintaxis funci&oacute;n-simil como array. No s&eacute; por qu&eacute; a esto no se le dio una sintaxis propiamente dedicada, o por qu&eacute; el nombre es tan obviamente confuso.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">(int)</span> est&aacute; obviamente dise&ntilde;ado para verse como C, pero es un token &uacute;nico; no hay nada llamado int en el lenguaje. Int&eacute;ntalo: no s&oacute;lo <span style="font-family: 'courier new', courier;">var_dump(int)</span> no funciona, arroja un error de parseo porque el argumento se parece como el operador de casting.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">(integer)</span> es un sin&oacute;nimo para <span style="font-family: 'courier new', courier;">(int)</span>. Tambi&eacute;n est&aacute;n&nbsp;<span style="font-family: 'courier new', courier;">(bool)</span> / <span style="font-family: 'courier new', courier;">(boolean)</span> y <span style="font-family: 'courier new', courier;">(float)</span> / <span style="font-family: 'courier new', courier;">(double)</span> / <span style="font-family: 'courier new', courier;">(real)</span>.</li>
<li style="text-align: justify;">Hay un operador <span style="font-family: 'courier new', courier;">(array)</span> para castear a arrays y <span style="font-family: 'courier new', courier;">(object)</span> para castear a objetos. Suela loco, pero hay al menos un uso: puedes usar <span style="font-family: 'courier new', courier;">(array)</span> para tener un argumento de una funci&oacute;n que sea o un item simple o una lista y tratarlo de forma id&eacute;ntica. Excepto que no puedes hacerlo con seguridad, porque si alguien pasa un &uacute;nico&nbsp;<em>objeto</em>, castearlo a un array producir&aacute; un array conteniendo los atributos del objeto. (Castear a object produce la operaci&oacute;n inversa.)</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">include()</span> y compa&ntilde;&iacute;a son b&aacute;sicamente el <span style="font-family: 'courier new', courier;">#include</span> de C: tiran el contenido de otro archivo de c&oacute;digo fuente en el tuyo. No hay sistema de m&oacute;dulos, ni siquiera para c&oacute;digo PHP.</li>
<li style="text-align: justify;">No hay algo como funciones o clases anidadas o locales. Son s&oacute;lo globales. Incluir un archivo pone sus variables en el &aacute;mbito de la funci&oacute;n actual (y le da al archivo acceso a tus variables), pero pone las funciones y clases en el &aacute;mbito global.</li>
<li style="text-align: justify;">Agregar a un array se hace con <span style="font-family: 'courier new', courier;">$foo[] = $bar</span>.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">echo</span> es algo estilo instrucci&oacute;n, no una funci&oacute;n.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">empty($var)</span> es tan extremadamente no-funci&oacute;n que cualquier cosa excepto una variable, por ejemplo, <span style="font-family: 'courier new', courier;">empty($var || $var2)</span>, es un error de parseo. &iquest;Por qu&eacute; en la Tierra tiene el parser que saber sobre <a href="http://phpsadness.com/sad/28"><span style="font-family: 'courier new', courier;">empty</span></a>?</li>
<li style="text-align: justify;">Hay sintaxis redundante para los bloques: <span style="font-family: 'courier new', courier;">if (...): ... endif;</span>, etc.</li>
</ul>
<h4>Manejo de errores</h4>
<ul>
<li style="text-align: justify;">El &uacute;nico operador de PHP es <span style="font-family: 'courier new', courier;">@</span> (de hecho, tomado prestado de DOS), que <em>silencia</em> errores.</li>
<li style="text-align: justify;">Los errores de PHP no proveen stack traces. Debes instalar un handler para que los genere. (Pero no puedes hacerlo para errores fatales -- ver abajo.)</li>
<li style="text-align: justify;">Los errores de parseo de PHP generalmente s&oacute;lo escupen el estado de parseo y nada m&aacute;s, haciendo una comilla olvidada <a href="http://phpsadness.com/sad/44">terrible para debuggear</a>.</li>
<li style="text-align: justify;">El parser de PHP se refiere, por ejemplo, a <span style="font-family: 'courier new', courier;">::</span> internamente como <span style="font-family: 'courier new', courier;">T_PAAMAYIM_NEKUDOTAYIM</span>, y al operador <span style="font-family: 'courier new', courier;"><<</span> como <span style="font-family: 'courier new', courier;">T_SL</span>. Digo "internamente" pero igual que arriba, esto es lo que se le muestra al programador cuando <span style="font-family: 'courier new', courier;">::</span> o <span style="font-family: 'courier new', courier;"><<</span> aparecen en el lugar equivocado.</li>
<li style="text-align: justify;">Mucho del manejo de errores es en la forma de imprimir una l&iacute;nea a un log en el servidor que nadie lee y seguir adelante.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">E_STRICT</span> est&aacute; ah&iacute;, pero no parece prevenir mucho y no hay documentaci&oacute;n sobre lo que en realidad hace.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">E_ALL</span> incluye todas las categorias de errores -- excepto <span style="font-family: 'courier new', courier;">E_STRICT</span>. (Arreglado en 5.4.)</li>
<li style="text-align: justify;">Es raramente inconsistente entre lo que est&aacute; permitido y lo que no. No s&eacute; c&oacute;mo <span style="font-family: 'courier new', courier;">E_STRICT</span>aplica ac&aacute;, pero estas cosas est&aacute;n permitidas:
<ul>
<li>Intentar acceder a una propiedad no existente en un objeto, i.e., <span style="font-family: 'courier new', courier;">$foo->x</span>. (Warning.)</li>
<li>Usar una variable como un nombre de funci&oacute;n, o nombre de variable, o nombre de clase. (Silencioso.)</li>
<li>Tratar de usar una constante no definida. (Notice.)</li>
<li>Tratar de acceder una propiedad de algo que no es un objeto. (Notice.)</li>
<li>Tratar de usar un nombre de variable que no existe. (Notice.)</li>
<li><span style="font-family: 'courier new', courier;">2 < "foo"</span> (silencioso)</li>
<li><span style="font-family: 'courier new', courier;">foreach (2 as $foo);</span> (warning)</li>
</ul>
</li>
<li style="text-align: justify;">(continuaci&oacute;n del punto anterior)<br />
Y estas cosas no lo est&aacute;n:</p>
<ul>
<li>Tratar de acceder una constante de una clase no existente, i.e., <span style="font-family: 'courier new', courier;">$foo::x</span>. (Error fatal.)</li>
<li>Usar una cadena constante como un nombre de funci'on, o nombre de variable, o nombre de clase. (Error de parseo.)</li>
<li>Tratar de llamar a una funci&oacute;n indefinida. (Error fatal.)</li>
<li>No poner un punto y coma en la &uacute;ltima instrucci&oacute;n en un bloque o archivo. (Error de parseo.)</li>
<li>Usar <span style="font-family: 'courier new', courier;">list</span> y cualquier otro quasi-elemento incorporado como nombre de m&eacute;todo. (Error de parseo.)</li>
<li>Subindicar el valor devuelto por una funci&oacute;n, i.e., <span style="font-family: 'courier new', courier;">foo()[0]</span>. (Error de parseo; permitido en 5.4, ver arriba.)</li>
</ul>
</li>
<li style="text-align: justify;">(continuaci&oacute;n del punto anterior)<br />
Hay otros buenos ejemplos de otros errores de parseo extra&ntilde;os en alg&uacute;n otro lado en esta lista.</li>
<li style="text-align: justify;">El m&eacute;todo <span style="font-family: 'courier new', courier;">__toString</span> no puede arrojar excepciones. Si intentar, PHP ... er... arrojar&aacute; una excepci&oacute;n. (De hecho, un error fatal, que podr&iacute;a ser aceptable, excepto...)</li>
<li style="text-align: justify;">Los errores de PHP y las excepciones de PHP son dos bestias completamente distintas. No parecen interactuar <em>para nada</em>.
<ul>
<li>Los errores de PHP (los internos, y las llamadas a <span style="font-family: 'courier new', courier;">trigger_error</span>) no se pueden atrapar con <span style="font-family: 'courier new', courier;">try</span> / <span style="font-family: 'courier new', courier;">catch</span>.</li>
<li>De forma similar, las excepciones no desatan manejadores de errores instalados por <span style="font-family: 'courier new', courier;">set_error_handler</span>.</li>
<li>En su lugar, hay un <span style="font-family: 'courier new', courier;">set_exception_handler</span> separado que maneja excepciones no atrapadas, porque envolver al punto de entrada de tu programa en un bloque <span style="font-family: 'courier new', courier;">try</span> es imposible en el modelo <span style="font-family: 'courier new', courier;">mod_php</span>.</li>
<li>Los errores fatales (por ejemplo, <span style="font-family: 'courier new', courier;">new ClassDoesntExist()</span>) no pueden ser atrapados por nada. <em>Muchas</em> de las cosas inofensivas arrojan errores fatales, terminando tu programa forzosamente por razones cuestionables. Las funciones de cierre a&uacute;n se ejecutar&aacute;n, pero no pueden obtener un stack trace (corren al nivel m&aacute;s alto) y no pueden f&aacute;cilmente determinar si el programa termin&oacute; por error o por haberse completado.</li>
</ul>
</li>
<li style="text-align: justify;">No hay una construcci&oacute;n <span style="font-family: 'courier new', courier;">finally</span>, haciendo al c&oacute;digo que envuelve otro c&oacute;digo (poner manejador, correr el c&oacute;digo, quitar el manejador; monkeypatch, correr un test, quitar el monkeypatch) tedioso y dif&iacute;cil de escribir. A pensar que la orientaci&oacute;n a objectos y las excepciones fueron en su mayor parte copiadas de Java, esto <a href="https://bugs.php.net/bug.php?id=32100">es deliberado</a>, porque finally "no tiene mucho sentido en el contexto de PHP". &iquest;Eh?</li>
</ul>
<h4>Funciones</h4>
<ul>
<li style="text-align: justify;">Las llamadas a funciones aparentemente son algo <a href="http://www.phpwtf.org/php-function-calls-have-quite-some-overhead">caras</a>.</li>
<li style="text-align: justify;">Algunas funciones incorporadas interact&uacute;an con las funciones que devuelven referencias en, ehm, <a href="http://www.phpwtf.org/php-function-calls-returning-references">una manera extra&ntilde;a</a>.</li>
<li style="text-align: justify;">Como est&aacute; mencionado en alg&uacute;n otro lado, muchas cosas que parecen funciones o se ven como que&nbsp;<em>deber&iacute;an ser</em> funciones, son de hecho construcciones del lenguaje, de forma que nada que trabaje con funciones trabajar&aacute; con ellas.</li>
<li style="text-align: justify;">Los argumentos de las funciones pueden tener "implicaci&oacute;n de tipos", que es b&aacute;sicamente tipado est&aacute;tico. Pero no puedes requerir que un argumento sea un <span style="font-family: 'courier new', courier;">int</span>, o <span style="font-family: 'courier new', courier;">string</span>, u <span style="font-family: 'courier new', courier;">object</span>, u otro tipo "del n&uacute;cleo", incluso cuando cualquier funci&oacute;n incorporada usa este tipo de tipado, probablemente porque <span style="font-family: 'courier new', courier;">int</span> no es nada en PHP. (Ver arriba sobre <span style="font-family: 'courier new', courier;">(int)</span>.) Tampoco puedes usar las <a href="http://www.php.net/manual/en/language.pseudo-types.php#language.types.mixed">decoraciones de pseudo-tipos</a> usada tanto en las funciones incorporadas: <span style="font-family: 'courier new', courier;">mixed</span>, <span style="font-family: 'courier new', courier;">number</span>, o <span style="font-family: 'courier new', courier;">callback</span>. (<span style="font-family: 'courier new', courier;">callable</span>est&aacute; permitido desde PHP 5.4.)
<ul>
<li>Como resultado, esto:<span style="font-family: 'courier new', courier;">function foo(string $s) {}</span><br />
<span style="font-family: 'courier new', courier;">foo("hello world");</span>produce el error:<span style="font-family: 'courier new', courier;">PHP Catchable fatal error: argument 1 passed to foo() must be an instance of string, string given, called in...</span></li>
<li>Puedes notar que el "implicado de tipo" dado no tiene que existir; no hay ninguna clase <span style="font-family: 'courier new', courier;">string</span> en este programa. Si intentas usar <span style="font-family: 'courier new', courier;">ReflectionParameter::getClass()</span> para examinar el implicado de tipos de forma din&aacute;mica, entonces negar&aacute; que la clase no existe, haciendo imposible obtener el nombre de la clase.</li>
<li>El valor devuelto por una funci&oacute;n no puede ser tipado.</li>
</ul>
</li>
<li style="text-align: justify;">Pasar los argumentos de una funci&oacute;n a otra funci&oacute;n (dispatching, no raro) es hecho llamando a <span style="font-family: 'courier new', courier;">call_user_func_array('other_function', func_get_args())</span>. Pero <span style="font-family: 'courier new', courier;">func_get_args</span> arroja un error fatal en tiempo de ejecuci&oacute;n, quej&aacute;ndose que no puede ser un par&aacute;metro de funci&oacute;n. &iquest;C&oacute;mo y por que es esto siquiera un <em>tipo</em> de error? (Arreglado en PHP 5.3.)</li>
<li style="text-align: justify;">Las clausuras requieren expl&iacute;citamente nombrar cada variable sobre la que se cerrar&aacute;. &iquest;Por qu&eacute; no puede el int&eacute;rprete detectarlo solo? Como que destroza el prop&oacute;sito de la caracter&iacute;stica. (Okay, es porque usar una variable en alg&uacute;n punto, en cualquier punto, la crea a menos que se le diga expl&iacute;citamente lo contrario.)</li>
<li style="text-align: justify;">Las variables sobre las que se cierra la clausura son "pasadas" por la misma sem&aacute;ntica que otros argumentos de funci&oacute;n. Eso es, arrays, strings, etc., ser&aacute;n "pasados" a la clausura por valor. A menos que uses <span style="font-family: 'courier new', courier;">&amp;</span>.</li>
<li style="text-align: justify;">Ya que las variables sobre las que se cierra la clausura son efectivamente argumentos autom&aacute;ticamente pasados y no hay &aacute;mbitos anidados, una clausura no se puede referir a m&eacute;todos privados, incluso si est&aacute; definido dentro de una clase. (&iquest;Posiblemente arreglado en 5.4? No est&aacute; claro.)</li>
<li style="text-align: justify;">No hay argumentos nombrados a las funciones. De hecho, <a href="http://www.php.net/~derick/meeting-notes.html#named-parameters">se rechazaron expl&iacute;citamente</a> por los desarrolladores porque "ayuda a c&oacute;digo m&aacute;s desprolijo".</li>
<li style="text-align: justify;">Los argumentos de funci&oacute;n con valores por defecto pueden aparecer antes que los argumentos de funci&oacute;n sin ellos, incluso aunque la documentaci&oacute;n aclara que esto es raro e in&uacute;til. (Entonces, &iquest;por qu&eacute; permitirlo?)</li>
<li style="text-align: justify;">Los argumentos extras a una funci&oacute;n son ignorados (excepto con funciones incorporadas, que arrojan un error). Los argumentos faltantes se asumen nulos.</li>
<li style="text-align: justify;">Las funciones "variadicas" requieren pelear con <span style="font-family: 'courier new', courier;">func_num_args</span>, <span style="font-family: 'courier new', courier;">func_get_arg</span> y <span style="font-family: 'courier new', courier;">func_get_args</span>. No hay sintaxis para algo as&iacute;.</li>
</ul>
<h4>Orientaci&oacute;n a Objetos (OO)</h4>
<ul>
<li style="text-align: justify;">Las partes procedurales de PHP est&aacute;n dise&ntilde;adas como C, pero la parte objeccional (jo jo) est&aacute;n dise&ntilde;adas como Java. No puedo sobreenfatizar lo discordante que esto es. El sistema de clases est&aacute; dise&ntilde;ado alrededor del lenguaje Java de <em>bajo-nivel</em>&nbsp;que es naturalmente y deliberadamente m&aacute;s limitado que los contemporarios de PHP, y estoy perplejo.
<ul>
<li>Todav&iacute;a debo encontrar alguna funci&oacute;n global que siquiera tenga una letra may&uacute;scula en su nombre, pero a&uacute;n as&iacute; varias <a href="http://www.php.net/manual/en/class.reflectionfunction.php">clases importantes incorporadas</a> usan nombres de m&eacute;todos camelCase y tienen m&eacute;todos de acceso <span style="font-family: 'courier new', courier;">getFoo</span> al estilo Java.</li>
<li>Perl, Python y Ruby, todos tienen alg&uacute;n concepto de acceso a "propiedad" v&iacute;a c&oacute;digo; PHP s&oacute;lo tiene el torpe <span style="font-family: 'courier new', courier;">__get</span> y sus amigos. (La documentaci&oacute;n inexplicablemente se refiere a esos m&eacute;todos especiales como "sobrecarga".)</li>
<li>Las clases tienen algo como la declaraci&oacute;n de variables (<span style="font-family: 'courier new', courier;">var</span> y <span style="font-family: 'courier new', courier;">const</span>) para atributos de clase, mientras que la parte procedural del lenguaje no.</li>
<li>A pesar de la pesada influencia de C++/Java, donde los objetos son medianamente opacos, PHP generalmente trata a los objetos como hashes bonitos -- por ejemplo, el comportamiento por defecto de <span style="font-family: 'courier new', courier;">foreach ($obj as $key => $value)</span> es para iterar sobre cada atributo accesible del objeto.</li>
</ul>
</li>
<li style="text-align: justify;">Las clases no son objetos. Cualquier tipo de metaprogramaci&oacute;n se debe referir a ellas con nombres en cadenas, igual que las funciones.</li>
<li style="text-align: justify;">Los tipos incorporados no son objetos y (a diferencia de Perl) no se pueden hacer parecer objetos de ninguna forma.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">instanceof</span> es un operador, a pesar que las clases fueron una adici&oacute;n tard&iacute;a y que mucho del lenguaje est&aacute; construido en funciones y sintaxis orientada a funciones. &iquest;Influencia de Java? &iquest;Las clases no son de primera clase? (No s&eacute; si lo son.)</li>
<li style="text-align: justify;">
<ul>
<li>Pero <em>s&iacute;</em> hay una funci&oacute;n <span style="font-family: 'courier new', courier;">is_a</span>. Con un argumento opcional indicando si se permite al objeto ser en realidad una cadena nombrando una clase.</li>
<li><span style="font-family: 'courier new', courier;">get_class</span> es una funci&oacute;n; no hay operador <span style="font-family: 'courier new', courier;">typeof</span>. Parecido a <span style="font-family: 'courier new', courier;">is_subclass_of</span>.</li>
<li>Esto no trabaja en tipos incorporadas, sin embargo (de nuevo, <span style="font-family: 'courier new', courier;">int</span> no es nada). Para eso necesitas <span style="font-family: 'courier new', courier;">is_int</span>, etc.</li>
<li>Tambi&eacute;n, el lado derecho debe ser una variable o una cadena literal; no puede ser una expresi&oacute;n. Eso causa... un error de parseo.</li>
</ul>
</li>
<li style="text-align: justify;">&iquest;!<span style="font-family: 'courier new', courier;">clone</span> es un operador!?</li>
<li style="text-align: justify;">Los atributos de objetos son <span style="font-family: 'courier new', courier;">$obj->foo</span>, pero los atributos de clases son <span style="font-family: 'courier new', courier;">Class::$foo</span>. (<span style="font-family: 'courier new', courier;">$obj::foo</span> intentar&aacute; convertir <span style="font-family: 'courier new', courier;">$obj</span> a string y usarlo como nombre de clase.) Los atributos de clase no pueden accederse desde los objetos, los espacios de nombres est&aacute;n completamente separados, haciendo que los atributos de clase sean completamente in&uacute;tiles para polimorfismo. Los&nbsp;<em>m&eacute;todos</em> de clase, por supuesto, est&aacute;n excemptos de esta regla y pueden ser llamdos como cualquier otro m&eacute;todo. (Me han dicho que C++ tambi&eacute;n hace esto. C++ no es un buen ejemplo de OO correcta.)</li>
<li style="text-align: justify;">Tambi&eacute;n, un m&eacute;todo de instancia puede ser llamado de forma est&aacute;tica. (<span style="font-family: 'courier new', courier;">Class::method()</span>). Si se hace desde otro m&eacute;todo, esto es tratado como una llamada regular a un m&eacute;todo en el <span style="font-family: 'courier new', courier;">$this</span> actual. Creo.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">new</span>, <span style="font-family: 'courier new', courier;">private</span>, <span style="font-family: 'courier new', courier;">public</span>, <span style="font-family: 'courier new', courier;">protected</span>, <span style="font-family: 'courier new', courier;">static</span>, etc. &iquest;Intentando ganar desarrolladores de Java? Soy consciente que esto es m&aacute;s una cuesti&oacute;n de gusto, pero no s&eacute; por qu&eacute; esto es necesario en un lenguaje din&aacute;mico -- en C++, mucho de esto se trata de compilaci&oacute;n y resoluci&oacute;n de nombres en tiempo de compilaci&oacute;n.</li>
<li style="text-align: justify;">PHP tiene soporte de primera clase para "clases abstractas", que son clases que no pueden ser instanciadas. El c&oacute;digo en lenguajes similares logra esto arrojando una excepci&oacute;n en el constructor.</li>
<li style="text-align: justify;">Las clases derivadas no pueden sobreescribir m&eacute;todos privados. Las sobreescrituras (overrides) de m&eacute;todos p&uacute;blicos no pueden siquiera&nbsp;<em>ver</em>, menos llamar, a los m&eacute;todos privados de la clase padre. Problem&aacute;tico para, digamos, mocks de testing.</li>
<li style="text-align: justify;">Los m&eacute;todos no se pueden nombrar, por ejemplo, "list", porque <span style="font-family: 'courier new', courier;">list()</span> es sintaxis especial (no una funci&oacute;n), y el parser se confunde. No hay raz&oacute;n por la que esto deber&iacute;a ser ambiguo, y hacer monkeypatching de la clase funciona bien. (<span style="font-family: 'courier new', courier;">$foo->list()</span> no es un error de sintaxis).</li>
<li style="text-align: justify;">Si una excepci&oacute;n es lanzada mientras se eval&uacute;an los argumentos de un constructor (por ejemplo, <span style="font-family: 'courier new', courier;">new Foo(bar())</span> y <span style="font-family: 'courier new', courier;">bar()</span> la arroja), el constructor no ser&aacute; llamado pero el&nbsp;<em>destructor&nbsp;</em>lo ser&aacute;. (Esto est&aacute; arreglado en PHP 5.3).</li>
<li style="text-align: justify;">Las excepciones en <span style="font-family: 'courier new', courier;">__autoload</span> y los destructores causan errores fatales. (Arreglado en PHP 5.3.6. Entonces ahora un destructor podr&iacute;a arrojar una excepci&oacute;n literalmente en cualquier lugar, dado que es llamado en el momento en donde el contador de referencias deja el zero. Hmm.)</li>
<li style="text-align: justify;">No hay constructores o destructores. <span style="font-family: 'courier new', courier;">__construct</span> es un inicializador, igual que el <span style="font-family: 'courier new', courier;">__init__</span> de Python. No hay m&eacute;todo que puedas llamar en una clase para reservar memoria y crear un objeto.</li>
<li style="text-align: justify;">No hay inicializador por defecto. Llamar a <span style="font-family: 'courier new', courier;">parent::_construct()</span> si la clase padre no define su propio <span style="font-family: 'courier new', courier;">__construct</span> es un error fatal.</li>
<li style="text-align: justify;">OO trae consigo una interfaz de interador que partes del lenguaje respetan (por ejemplo, <span style="font-family: 'courier new', courier;">for...as</span>), pero nada incorporado (como los arrays) implementa la interfaz. Si quieres un iterador de array, debes envolverlo en un <span style="font-family: 'courier new', courier;">ArrayIterator</span>. No hay maneras incorporadas de encadenar llamadas o partir collecciones o trabajar de alguna otra forma con los iteradores como objetos de primera clase.</li>
<li style="text-align: justify;">Las interfaces como <span style="font-family: 'courier new', courier;">Iterator</span> se reservan unos beuenos m&eacute;todos sin prefijos. Si quieres que tu clase sera iterable (sin el comportamiento por defecto de iterar en todos sus atributos), pero quieres usar un m&eacute;todo com&uacute;n como <span style="font-family: 'courier new', courier;">key</span>, o <span style="font-family: 'courier new', courier;">next</span>, o <span style="font-family: 'courier new', courier;">current</span>, bueno, l&aacute;stima.</li>
<li style="text-align: justify;">Las clases pueden sobrecargar c&oacute;mo se convierten a strings y c&oacute;mo act&uacute;an cuando son llamadas, pero no c&oacute;mo se convierten a n&uacute;meros ni a ning&uacute;n otro tipo incorporado.</li>
<li style="text-align: justify;">Las cadenas, n&uacute;meros y arrays todos tienen conversiones a cadena; el lenguaje recae fuertemente en esto. Las funciones y las clases&nbsp;<em>son</em> cadenas. A&uacute;n as&iacute;, intentar convertir un objeto incorporado o definido por el usuario (incluso una clausura) a un string causa un error si no se define <span style="font-family: 'courier new', courier;">__toString</span>. Incluso <span style="font-family: 'courier new', courier;">echo</span> se convierte en propenso a errores.</li>
<li style="text-align: justify;">No hay sobrecarga para igualdad u ordenamiento.</li>
<li style="text-align: justify;">Las variables est&aacute;ticas dentro de los m&eacute;todos de instancias son globales; tienen el mismo valor en todas las instancias de la clase.</li>
</ul>
<h3>Librer&iacute;a est&aacute;ndar</h3>
<p style="text-align: justify;">Perl es "algo de construcci&oacute;n necesaria". Python es "bater&iacute;as incluidas". PHP es "de todo y m&aacute;s, pero es de Canad&aacute; y <a href="http://mcguirehimself.com/?p=4146">ambas llaves dicen C</a>".</p>
<h4>General</h4>
<ul>
<li style="text-align: justify;">No hay sistema de m&oacute;dulos. Puedes compilar extensiones PHP, pero las que se carguen son especificadas en php.ini, y tus opciones son que una extensi&oacute;n exista (e inyecte sus contenidos en el espacio de nombres global) o no.</li>
<li style="text-align: justify;">Como los espacios de nombres son una caracter&iacute;stica reciente, la librer&iacute;a est&aacute;ndar no est&aacute; dividida para nada. Hay miles de funciones en el espacio de nombres global.</li>
<li style="text-align: justify;">Pedazos de la librer&iacute;a son terriblemente inconsistentes de otros.
<ul>
<li>Gui&oacute;n bajo versus sin gui&oacute;n bajo: <span style="font-family: 'courier new', courier;">strpos</span> / <span style="font-family: 'courier new', courier;">str_rot13</span>, <span style="font-family: 'courier new', courier;">php_uname</span> / <span style="font-family: 'courier new', courier;">phpversion</span>, <span style="font-family: 'courier new', courier;">base64_encode</span> / <span style="font-family: 'courier new', courier;">urlencode</span>, <span style="font-family: 'courier new', courier;">gettype</span> / <span style="font-family: 'courier new', courier;">get_class</span>.</li>
<li>"to" versus "2": <span style="font-family: 'courier new', courier;">ascii2ebcdic</span>, <span style="font-family: 'courier new', courier;">bin2hex</span>, <span style="font-family: 'courier new', courier;">deg2grad</span>, <span style="font-family: 'courier new', courier;">strtolower</span>, <span style="font-family: 'courier new', courier;">strtotime</span>.</li>
<li>Objeto+verbo versus verbo+objeto: <span style="font-family: 'courier new', courier;">base64_decode</span>, <span style="font-family: 'courier new', courier;">str_shuffle</span>, <span style="font-family: 'courier new', courier;">var_dump</span> versus <span style="font-family: 'courier new', courier;">create_function</span>, <span style="font-family: 'courier new', courier;">recode_string</span>.</li>
<li>Orden de argumentos: <span style="font-family: 'courier new', courier;">array_filter($input, $callback)</span> versus <span style="font-family: 'courier new', courier;">array_map($callback, $input)</span>, <span style="font-family: 'courier new', courier;">strpos($haystack, $needle)</span> versus <span style="font-family: 'courier new', courier;">array_search($needle, $haystack)</span>.</li>
<li>Confusi&oacute;n de prefijos: <span style="font-family: 'courier new', courier;">usleep</span> versus <span style="font-family: 'courier new', courier;">microtime</span>.</li>
<li>Funciones insensitivas a may&uacute;sculas y min&uacute;sculas que var&iacute;an en donde la <span style="font-family: 'courier new', courier;">i</span> va en el nombre.</li>
<li>Alrededor de la mitad de las funciones de arrays comienzan con <span style="font-family: 'courier new', courier;">array_</span>. Las otras no.</li>
<li><span style="font-family: 'courier new', courier;">htmlentities</span> y <span style="font-family: 'courier new', courier;">html_entity_decode</span> son <em>inversas</em> una de la otra, con convenciones de nombre completamente distintas.</li>
</ul>
</li>
<li>De todo y algo m&aacute;s. La librer&iacute;a incluye:
<ul>
<li style="text-align: justify;">Bindeos a ImageMagick, bindeos a GraphicsMagick (que es un fork de ImageMagick), y un pu&ntilde;ado de funciones para inspeccionar datos EXIF (que ImageMagick ya puede hacer).</li>
<li style="text-align: justify;">Funciones para parsear bbcode, un tipo de markup muy espec&iacute;fico utilizado por un pu&ntilde;ado de paquetes de foros.</li>
<li style="text-align: justify;">Demasiados paquetes XML. <span style="font-family: 'courier new', courier;">DOM</span> (orientado a objetos), <span style="font-family: 'courier new', courier;">DOM XML</span> (no), <span style="font-family: 'courier new', courier;">libxml</span>, <span style="font-family: 'courier new', courier;">SimpleXML</span>, "XML Parser", <span style="font-family: 'courier new', courier;">XMLReader</span>/<span style="font-family: 'courier new', courier;">XMLWriter</span>, y otra media docena de acr&oacute;nimos que no puedo identificar. Hay seguramente alg&uacute;n tipo de diferencia entre estas cosas y eres libre de averiguar cu&aacute;l es.</li>
<li style="text-align: justify;">Bindings para dos procesadores espec&iacute;ficos de tarjetas de cr&eacute;dito, SPPLUS y MCVE. &iquest;Qu&eacute;?</li>
<li style="text-align: justify;">Tres maneras de acceder a una base de datos MySQL: <span style="font-family: 'courier new', courier;">mysql</span>, <span style="font-family: 'courier new', courier;">mysqli</span>, y la cosa esa de abtracci&oacute;n <span style="font-family: 'courier new', courier;">PDO</span>.</li>
</ul>
</li>
</ul>
<h4>Influencia de C</h4>
<p style="text-align: justify;">Esto merece su propio t&iacute;tulo, porque es tan absurdo y a&uacute;n as&iacute; permea al lenguaje. PHP es un lenguaje de programaci&oacute;n de alto nivel din&aacute;micamente tipado. A&uacute;n as&iacute; una porci&oacute;n masiva de la librer&iacute;a est&aacute;ndar son a&uacute;n wrappers muy finos sobre APIs de C, con los siguientes resultados:</p>
<ul>
<li style="text-align: justify;">Par&aacute;metros "out", incluso a pesar de que PHP puede devolver hashes ad-hoc o m&uacute;ltiples argumentos con poco esfuerzo.</li>
<li style="text-align: justify;">Al menos una docena de funciones para obtener el &uacute;ltimo error de un subsistema en particular (ver m&aacute;s abajo), a pesar de que PHP ha tenido excepciones por ocho a&ntilde;os.</li>
<li style="text-align: justify;">Verrugas como <span style="font-family: 'courier new', courier;">mysql_real_escape_string</span>, a pesar de que tiene los mismos argumentos que <span style="font-family: 'courier new', courier;">mysql_escape_string</span>, s&oacute;lo porque es parte de la API C de MySQL.</li>
<li style="text-align: justify;">Comportamiento global para funcionalidad no-global (como MySQL). Usar m&uacute;ltiples conexiones a MySQL aparentemente requiere pasar un identificador de conexi&oacute;n en cada llamada a funci&oacute;n.</li>
<li style="text-align: justify;">Los wrappers son realmente, realmente finos. Por ejemplo, llamar a <span style="font-family: 'courier new', courier;">dba_nextkey</span> sin llamar a <span style="font-family: 'courier new', courier;">dba_firstkey</span> generar&aacute; un error de segmentaci&oacute;n.</li>
<li style="text-align: justify;">Hay un conjunto de funciones <span style="font-family: 'courier new', courier;">ctype_*</span> (por ejemplo, <span style="font-family: 'courier new', courier;">ctype_alnum</span>), que mapean a las funciones de detecci&oacute;n de clases de caracteres de C de nombres similares, a pesar de, digamos, <span style="font-family: 'courier new', courier;">isupper</span>.</li>
</ul>
<h4>Genericismo</h4>
<p style="text-align: justify;">No hay ninguno. Si una funci&oacute;n tiene que hacer dos cosas ligeramente distintas, PHP simplemente tiene dos funciones.</p>
<p style="text-align: justify;">&iquest;C&oacute;mo ordenas en orden inverso? En Perl podr&iacute;as hacer <span style="font-family: 'courier new', courier;">sort { $b <=> $a }</span>. En Python, podr&iacute;as hacer <span style="font-family: 'courier new', courier;">sort(reverse=True)</span>. En PHP hay una funci&oacute;n separada llamada <span style="font-family: 'courier new', courier;">rsort()</span>.</p>
<ul>
<li style="text-align: justify;">Funciones que buscan un error de C: <span style="font-family: 'courier new', courier;">curl_error</span>, <span style="font-family: 'courier new', courier;">json_last_error</span>, <span style="font-family: 'courier new', courier;">openssl_error_string</span>, <span style="font-family: 'courier new', courier;">imap_errors</span>, <span style="font-family: 'courier new', courier;">mysql_error</span>, <span style="font-family: 'courier new', courier;">xml_get_error_code</span>, <span style="font-family: 'courier new', courier;">bzerror</span>, <span style="font-family: 'courier new', courier;">date_get_last_errors</span>, &iquest;otras?</li>
<li style="text-align: justify;">Funciones que ordenan: <span style="font-family: 'courier new', courier;">array_multisort</span>, <span style="font-family: 'courier new', courier;">arsort</span>, <span style="font-family: 'courier new', courier;">asort</span>, <span style="font-family: 'courier new', courier;">ksort</span>, <span style="font-family: 'courier new', courier;">krsort</span>, <span style="font-family: 'courier new', courier;">natsort</span>, <span style="font-family: 'courier new', courier;">natcasesort</span>, <span style="font-family: 'courier new', courier;">sort</span>, <span style="font-family: 'courier new', courier;">rsort</span>, <span style="font-family: 'courier new', courier;">uasort</span>, <span style="font-family: 'courier new', courier;">uksort</span>, <span style="font-family: 'courier new', courier;">usort</span>.</li>
<li style="text-align: justify;">Funciones que encuentran texto: <span style="font-family: 'courier new', courier;">ereg</span>, <span style="font-family: 'courier new', courier;">eregi</span>, <span style="font-family: 'courier new', courier;">mb_ereg</span>, <span style="font-family: 'courier new', courier;">mb_eregi</span>, <span style="font-family: 'courier new', courier;">preg_match</span>, <span style="font-family: 'courier new', courier;">strstr</span>, <span style="font-family: 'courier new', courier;">strchr</span>, <span style="font-family: 'courier new', courier;">stristr</span>, <span style="font-family: 'courier new', courier;">strrchr</span>, <span style="font-family: 'courier new', courier;">strpos</span>, <span style="font-family: 'courier new', courier;">stripos</span>, <span style="font-family: 'courier new', courier;">strrpos</span>, <span style="font-family: 'courier new', courier;">strripos</span>, <span style="font-family: 'courier new', courier;">mb_strpos</span>, <span style="font-family: 'courier new', courier;">mb_strrpos</span>, m&aacute;s las variaciones que hacen reemplazos.</li>
<li style="text-align: justify;">Hay muchos alias tambi&eacute;n, lo que ciertamente no ayuda al tema: <span style="font-family: 'courier new', courier;">strstr</span> / <span style="font-family: 'courier new', courier;">strchr</span>, <span style="font-family: 'courier new', courier;">is_int</span> / <span style="font-family: 'courier new', courier;">is_integer</span> / <span style="font-family: 'courier new', courier;">is_long</span>, <span style="font-family: 'courier new', courier;">is_float</span> / <span style="font-family: 'courier new', courier;">is_double</span>, <span style="font-family: 'courier new', courier;">pos</span> / <span style="font-family: 'courier new', courier;">current</span>, <span style="font-family: 'courier new', courier;">sizeof</span> / <span style="font-family: 'courier new', courier;">count</span>, <span style="font-family: 'courier new', courier;">chop</span> / <span style="font-family: 'courier new', courier;">rtrim</span>, <span style="font-family: 'courier new', courier;">implode</span> / <span style="font-family: 'courier new', courier;">join</span>, <span style="font-family: 'courier new', courier;">die</span> / <span style="font-family: 'courier new', courier;">exit</span>, <span style="font-family: 'courier new', courier;">trigger_error</span> / <span style="font-family: 'courier new', courier;">user_error</span>, <span style="font-family: 'courier new', courier;">diskfreespace</span> / <span style="font-family: 'courier new', courier;">disk_free_space</span>, ...</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">scandir</span> devuelve un listado de archivos en un directorio dado. En lugar de (potencialmente &uacute;til) devolverlos en el orden del directorio, la funci&oacute;n devuelve los archivos ya ordenados. Y hay un argumento opcional para obtenerlos en orden alfab&eacute;tico <em>inverso</em>. No hab&iacute;a, aparentemente, suficientes funciones de ordenamiento. (PHP 5.4 agrega un tercer valor para la direcci&oacute;n del ordenamiento que deshabilitar&aacute; el ordenamiento.)</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">str_split</span> partir&aacute; una cadena en pedazos de igual tama&ntilde;o. <span style="font-family: 'courier new', courier;">chunk_split</span> parte una cadena en pedazos de igual tama&ntilde;o y luego los une con un delimitador.</li>
<li style="text-align: justify;">Leer archivos requiere un conjunto separado de funciones dependiendo del formato. Hay seis grupos separados de esas funciones, todas con APIs diferentes, para bzip2, LZF, phar, rar, zip y gzip/zlib.</li>
<li style="text-align: justify;">Ya que llamar a una funci&oacute;n con un array como sus argumentos es tan raro (<span style="font-family: 'courier new', courier;">call_user_func_array</span>), hay algunos pares como <span style="font-family: 'courier new', courier;">printf</span> / <span style="font-family: 'courier new', courier;">vprintf</span> y <span style="font-family: 'courier new', courier;">sprintf</span> / <span style="font-family: 'courier new', courier;">vsprintf</span>. Estos hacen lo mismo, pero una funci&oacute;n toma argumentos y la otra toma un array de argumentos.</li>
</ul>
<h4>Texto</h4>
<ul>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">preg_replace</span> con la opci&oacute;n <span style="font-family: 'courier new', courier;">/e</span> (eval) har&aacute; un reemplazo de los resultados encontrados con una cadena de texto, y <em>luego la eval&uacute;a</em>.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">strtok</span> est&aacute; aparentemente dise&ntilde;ado desde la funci&oacute;n C equivalente, la que ya es una mala idea por varias razones. Dejando de lado que PHP puede f&aacute;cilmente deolver un array (mientras esto es raro en C), o que el mismo hack que <span style="font-family: 'courier new', courier;">strtok(3)</span> usa (modificando la cadena en-el-lugar) no es usada aqu&iacute;.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">parse_str</span> parsea un query string, con ninguna indicaci&oacute;n en su nombre. Tambi&eacute;n act&uacute;a igual que <span style="font-family: 'courier new', courier;">register_globals</span> y arroja el query en tu &aacute;mbito local como variables, a menos que le pases un array para que popule. (No devuelve nada, por supuesto.)</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">explode</span> se rehusa a separar cadenas con un limitador vac&iacute;o o faltante. Todas las otras implementaciones de separaci&oacute;n de cadenas hace algo &uacute;til en este caso; PHP en cambio tiene una funci&oacute;n completamente separada, confusamente llamada <span style="font-family: 'courier new', courier;">str_split</span> y descripta como "convierte una cadena a un array".</li>
<li style="text-align: justify;">Para formatear fechas, est&aacute; <span style="font-family: 'courier new', courier;">strftime</span>, que act&uacute;a como la API de C y respeta el lugar. Tambi&eacute;n est&aacute; date, que tiene una sintaxis completamente distinta y s&oacute;lo funciona en ingl&eacute;s.</li>
<li style="text-align: justify;">"<span style="font-family: 'courier new', courier;"><a href="http://php.net/manual/en/function.gzgetss.php">gzgetss</a> </span>-- Obtiene una l&iacute;nea desde un puntero a un archivo gz y remueve las etiquetas HTML." Me estoy muriendo por conocer la serie de circunstancias que llevaron a la concepci&oacute;n de esta funci&oacute;n.</li>
<li><span style="font-family: 'courier new', courier;">mbstring</span>
<ul>
<li style="text-align: justify;">Es todo sobre "multi-byte", cuando el problema son los conjuntos de caracteres.</li>
<li style="text-align: justify;">A&uacute;n as&iacute; opera en cadenas comunes. Tiene un conjunto de caracteres "por defecto" global. Algunas funciones permiten un conjunto espec&iacute;fico, pero luego aplica a todos los argumentos y el valor de retorno.</li>
<li style="text-align: justify;">Provee funciones <span style="font-family: 'courier new', courier;">ereg_*</span>, pero esas est&aacute;n obsoletas. <span style="font-family: 'courier new', courier;">preg_*</span> no tienen suerte, aunque pueden entender UTF-8 pas&aacute;ndoles un indicador PCRE espec&iacute;fico.</li>
</ul>
</li>
</ul>
<h4>Sistema y reflexi&oacute;n</h4>
<ul>
<li style="text-align: justify;">Hay, en general, muchas funciones que bordean la l&iacute;nea entre texto y variables. <span style="font-family: 'courier new', courier;">compact</span> y <span style="font-family: 'courier new', courier;">extract</span> son s&oacute;lo la punta del iceberg.</li>
<li style="text-align: justify;">Hay muchas formas de ser din&aacute;mico en PHP, y en una primera mirada no hay una diferencia obvia o beneficios orelativos. <span style="font-family: 'courier new', courier;">classkit</span> puede modificar clases definidas por el usuario; <span style="font-family: 'courier new', courier;">runkit</span> lo suplanta y puede modificar cualquier cosa definida por el usuario; las clases <span style="font-family: 'courier new', courier;">Reflection*</span> pueden reflexionar en la mayor parte del lenguaje; hay una buena cantidad de funciones individuales para reportar propiedades de funciones y clases. &iquest;Son estos subsistemas independientes, relacionados, redundantes?</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">get_class($obj)</span> devuelve el nombre de la clase del objeto, <span style="font-family: 'courier new', courier;">get_class()</span> devuelve el nombre de la clase de la funci&oacute;n que lo llama. Dejando de lado que esta &uacute;nica funci&oacute;n hace dos cosas radicalmente distintas: <span style="font-family: 'courier new', courier;">get_class(null)</span> funciona como el segundo. Por tanto no se lo puede confiar en un valor arbitrario. &iexcl;Sorpresa!</li>
<li style="text-align: justify;">Las clases <span style="font-family: 'courier new', courier;">stream_*</span> permiten implementar objetos de flujos de datos personalizados para usar con <span style="font-family: 'courier new', courier;">fopen</span> y otros elementos inherentes archivezcos. "tell" no puede ser implementado por <a href="https://bugs.php.net/bug.php?id=30157">razones internas</a>. (Tambi&eacute;n hay <a href="http://www.php.net/manual/en/book.stream.php">MUCHAS</a> funciones involucradas con este sistema.)</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">register_tick_function</span> aceptar&aacute; un objeto clausura. <span style="font-family: 'courier new', courier;">unregister_tick_function</span> no; en lugar de eso arroja un error quej&aacute;ndose de que la clausura no puede ser convertida a cadena.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">php_uname</span> te cuenta sobre el sistema operativo actual. A menos que PHP no pueda decir en qu&eacute; est&aacute; corriendo, en cuyo caso te cuenta sobre el sistema operativo en el que fue <em>compilado</em>. No te avisar&aacute; si esto ocurri&oacute;.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">fork</span> y <span style="font-family: 'courier new', courier;">exec</span> no son propios del lenguaje. Vienen con la extensi&oacute;n pcntl, pero no est&aacute; incluida por defecto. <span style="font-family: 'courier new', courier;">popen</span> no provee un pid.</li>
<li style="text-align: justify;">El valor de retorno de <span style="font-family: 'courier new', courier;">stat</span> es cacheado.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">session_decode</span> es para leer una cadena de sesi&oacute;n PHP arbitraria, pero s&oacute;lo funciona si ya hay una sesi&oacute;n activa. Y deja el resultado en <span style="font-family: 'courier new', courier;">$_SESSION</span>, en lugar de devolverlo.</li>
</ul>
<h4>Miscel&aacute;neos</h4>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;"><span style="font-family: 'courier new', courier;">curl_multi_exec</span> no cambia <span style="font-family: 'courier new', courier;">curl_errno</span> cuando ocurre un error, pero s&iacute; cambia <span style="font-family: 'courier new', courier;">curl_error</span>.</span></li>
<li style="text-align: justify;">Los argumentos de <span style="font-family: 'courier new', courier;">mktime</span> son, en orden: hora, minuto, segundo, mes, d&iacute;a, a&ntilde;o.</li>
</ul>
<h3>Manipulaci&oacute;n de datos</h3>
<p style="text-align: justify;">Los programas no son m&aacute;s que grandes m&aacute;quinas que mastican datos y escupen m&aacute;s datos. Varios lenguajes grandiosos est&aacute;n dise&ntilde;ados&nbsp;<em>alrededor</em> de los tipos de datos que manipulan, desde awk hasta Prolog, hasta C. Si un lenguaje no puede manejar datos, no puede hacer nada.</p>
<h4>N&uacute;meros</h4>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">Los enteros tienen signo y tienen 32 bits en plataformas de 32 bits. A diferencia de todos los contemporarios de PHP, no hay promoci&oacute;n autom&aacute;tica a bigint. Por lo que puedes terminar con sorpresas como tama&ntilde;os de archivos negativos, y tu matem&aacute;tica puede funcionar diferentemente basada en la&nbsp;<em>arquitectura del CPU</em>. Tu &uacute;nica opci&oacute;n para enteros m&aacute;s grandes es usar las funciones wrapper GMP o BC. (Los desarrolladores han propuesto <a href="http://www.php.net/~derick/meeting-notes.html#add-a-64bit-integer">a&ntilde;adir un nuevo tipo, separado, de 64 bits</a>. Esto es locura.)</span></li>
<li style="text-align: justify;">PHP soporta sintaxis octal con un <span style="font-family: 'courier new', courier;">0</span> inicial, por lo que, por ejemplo, <span style="font-family: 'courier new', courier;">012</span> ser&aacute; el n&uacute;mero diez. Sin embargo, <span style="font-family: 'courier new', courier;">08</span> se convierte en el n&uacute;mero cero. El <span style="font-family: 'courier new', courier;">8</span> (o <span style="font-family: 'courier new', courier;">9</span>) y cualquier d&iacute;gito posterior desaparecen. <span style="font-family: 'courier new', courier;">01c</span> es un error de sintaxis.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">0x0+2</span> produce 4. El parser considera el <span style="font-family: 'courier new', courier;">2</span> como parte simult&aacute;nea del literal hexadecimal&nbsp;<em>y</em> como un literal decimal separado, tratando esto como <span style="font-family: 'courier new', courier;">0x002 + 2</span>. <span style="font-family: 'courier new', courier;">0x0+0x2</span> muestra el mimo problema. Extra&ntilde;amente, <span style="font-family: 'courier new', courier;">0x0 +2</span> es todav&iacute;a 4, pero <span style="font-family: 'courier new', courier;">0x0+ 2</span> es correctamente 2. (Esto se arregl&oacute; en PHP 5.4. Pero tambi&eacute;n se volvi&oacute; a romper en PHP 5.4 con el nuevo prefijo literal <span style="font-family: 'courier new', courier;">0b</span>: <span style="font-family: 'courier new', courier;">0b0+1</span> produce 2.)</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">pi</span> es una funci&oacute;n. O hay una constante, <span style="font-family: 'courier new', courier;">M_PI</span>.</li>
<li style="text-align: justify;">No hay <a href="https://bugs.php.net/bug.php?id=13756">operador de exponenciaci&oacute;n</a>, s&oacute;lo la funci&oacute;n <span style="font-family: 'courier new', courier;">pow</span>.</li>
</ul>
<h4>Texto</h4>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">No hay soporte Unicode. S&oacute;lo ASCII trabajar&aacute; confiablemente. Existe la extensi&oacute;n <span style="font-family: 'courier new', courier;">mbstring</span>, mencionada arriba, pero apesta un poco.</span></li>
<li style="text-align: justify;">Lo que significa que usar las funciones incorporadas en texto UTF-8 lo corrompe.</li>
<li style="text-align: justify;">Similarmente, no hay concepto de, por ejemplo, comparaciones de may&uacute;sculas o min&uacute;sculas fuera de ASCII. A pesar de la proliferaci&oacute;n de versiones insensitivas a la capitalizaci&oacute;n de las funciones, ninguna de ellas considerar&aacute; <span style="font-family: 'courier new', courier;">&eacute;</span> igual a <span style="font-family: 'courier new', courier;">&Eacute;</span>.</li>
<li style="text-align: justify;">No puedes encomillar claves en interpolaci&oacute;n de variables, es decir, <span style="font-family: 'courier new', courier;">"$foo['key']"</span> es un error de sintaxis. Puedes des-encomillarlo (lo que <em>s&iacute;</em> generar&iacute;a una advertencia en cualquier otro lugar!), o usar <span style="font-family: 'courier new', courier;">${...}</span>/<span style="font-family: 'courier new', courier;">{$...}</span>.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">"${foo[0]}"</span> est&aacute; bien. <span style="font-family: 'courier new', courier;">"${foo[0][0]}"</span> es un error de sintaxis. Poner el <span style="font-family: 'courier new', courier;">$</span> dentro est&aacute; bien en ambos casos. &iquest;Mala copia de la sintaxis similar de Perl (con sem&aacute;nticas radicalmente distintas)?</li>
</ul>
<h4>Arreglos</h4>
<p>Oh...</p>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">Este tipo de datos act&uacute;a como lista, hash ordenado, conjunto ordenado, lista dispersa, y ocasionalmente alguna combinaci&oacute;n extra&ntilde;a de esos. &iquest;C&oacute;mo se desempe&ntilde;a? &iquest;Qu&eacute; tipo de uso de memoria habr&aacute; ah&iacute;? &iquest;Qui&eacute;n sabe? De cualquier modo, no es como si tuviera otras opciones.</span></li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">=></span> no es un operador. Es una construcci&oacute;n especial que s&oacute;lo existe dentro de <span style="font-family: 'courier new', courier;">array(...)</span> y la construcci&oacute;n <span style="font-family: 'courier new', courier;">foreach</span>.</li>
<li style="text-align: justify;">El indexado negativo no funciona, ya que <span style="font-family: 'courier new', courier;">-1</span> es una clave v&aacute;lida como <span style="font-family: 'courier new', courier;">0</span>.</li>
<li style="text-align: justify;">A pesar de que esta es la &uacute;nica estructura de datos del lenguaje, no hay sintaxis corta para &eacute;l; <span style="font-family: 'courier new', courier;">array(...)</span> es la sintaxis corta. (PHP 5.4 trae "literales", <span style="font-family: 'courier new', courier;">[...]</span>.)</li>
<li style="text-align: justify;">La construcci&oacute;n <span style="font-family: 'courier new', courier;">=></span> est&aacute; basada en Perl, que permite <span style="font-family: 'courier new', courier;">foo => 1</span>, sin comillas. (Eso es, de hecho, porque existen en Perl; de otra forma es s&oacute;lo una coma.) En PHP no puedes hacer esto sin obtener una advertencia; es el &uacute;nico lenguaje en su nicho que no tiene forma aprobada de crear un hash sin encomillar las claves de cadena.</li>
<li style="text-align: justify;">Las funciones de arreglos por lo general tienen comportamietno confuso o inconsistente porque tienen que operar en listas, hashes o quiz&aacute; una combinaci&oacute;n de los dos. Consideren <span style="font-family: 'courier new', courier;">array_diff</span>, que "computa la diferencia de los arreglos".<br />
<span style="font-family: 'courier new', courier;">$primero = array("foo" => 123, "bar" => 456);</span><br />
<span style="font-family: 'courier new', courier;">$segundo = array("foo" => 456, "bar" => 123);</span><br />
<span style="font-family: 'courier new', courier;">echo var_dump(array_diff($primero, $segundo));</span><br />
&iquest;Qu&eacute; har&aacute; este c&oacute;digo? Si <span style="font-family: 'courier new', courier;">array_diff</span> trata sus argumentos como hashes, obviamente estos son diferentes; las mismas claves tienen distintos valores. Si los trata como listas, a&uacute;n son distintas; los valores est&aacute;n en orden distinto.<br />
En realidad <span style="font-family: 'courier new', courier;">array_diff</span> considera a estos iguales, porque los trata como <em>conjuntos</em>, compara solamente valores e ignora el orden.</li>
<li style="text-align: justify;">En una vena similar, <span style="font-family: 'courier new', courier;">array_rand</span> tiene el extra&ntilde;o comportamiento de seleccionar&nbsp;<em>claves</em> al azar, que no es tan &uacute;til para el caso m&aacute;s com&uacute;n de necesitar elegir de un listado de opciones.</li>
<li style="text-align: justify;">A pesar de lo mucho que el c&oacute;digo PHP recae en preservar el orden de las claves:<br />
<span style="font-family: 'courier new', courier;">array("foo", "bar") != array("bar", "foo")</span><br />
<span style="font-family: 'courier new', courier;">array("foo" => 1, "bar" => 2) == array("bar" => 2, "foo" => 1)</span><br />
Dejo como ejercicio al lector averiguar qu&eacute; ocurre si los arreglos son mezclas. (Yo no lo s&eacute;.)</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">array_fill</span> no puede crear arreglos de tama&ntilde;o cero, en lugar de eso emitir&aacute; una advertencia y devolver&aacute; falso.</li>
<li style="text-align: justify;">Todas de las (muchas...) funciones de ordenamiento operan en-el-lugar y no devuelven nada. No hay forma de crear una copia ordenada; hay que copiar el arreglo manualmente, luego ordenarlo, y luego usarlo.</li>
<li style="text-align: justify;">Pero <span style="font-family: 'courier new', courier;">array_reverse</span> devuelve un nuevo arreglo.</li>
<li style="text-align: justify;">Un listado de cosas ordenadas y algunos mapeos de claves a valores suena como una gran manera de manejar argumentos de funciones, pero no.</li>
</ul>
<h4>No arreglos</h4>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">La librer&iacute;a est&aacute;ndar incluye "Quickhash" &nbsp;una implementaci&oacute;n OO de "clases espec&iacute;ficas fuertemente tipadas" para implementar hashes. Y, efectivamente, hay cuatro clases, cada una tratando una combinaci&oacute;n distinta de tipos de claves y valores. No est&aacute; claro por qu&eacute; la implementaci&oacute;n incorporada de arreglos no puede optimizar para estos casos extremadamente comunes, o lo que la performance relativa es.</span></li>
<li style="text-align: justify;">Hay una clase <span style="font-family: 'courier new', courier;">ArrayObject</span> (que implemente <em>cinco</em> interfaces distintas) que puede envolver a un arreglo y permitirle actuar como objeto. Las clases de usuario pueden implementar las mismas interfaces. Pero s&oacute;lo tienen un pu&ntilde;ado de m&eacute;todos, la mitad de los cuales no se parecen a las funciones incorporadas, y las funciones incorporadas de arreglos no saben c&oacute;mo operar con un <span style="font-family: 'courier new', courier;">ArrayObject</span> o cualquier otra clase parecida a arreglos.</li>
</ul>
<h4>Funciones</h4>
<ul>
<li style="text-align: justify;">Las funciones no son datos. Las clausuras son de hecho objetos, pero las funciones comunes no. No puedes referirte a ellas con sus nombres; <span style="font-family: 'courier new', courier;">var_dump(strstr)</span> emite una advertenia y asume que quer&iacute;as la cadena <span style="font-family: 'courier new', courier;">literal "strstr"</span>. No hay manera de discernir entre una cadena arbitraria y una "referencia" a funci&oacute;n.</li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">create_function</span> es b&aacute;sicamente un wrapper alrededor de <span style="font-family: 'courier new', courier;">eval</span>. Crea una funci&oacute;n con un nombre com&uacute;n y la instala globalmente (para que nunca sea recolectada por el recolector de basura -- &iexcl;no la uses en un bucle!). De hecho no sabe nada sobre el &aacute;mbito actual, por lo que no es una clausura. El nombre contiene un byte <span style="font-family: 'courier new', courier;">NUL</span> para que nunca pueda entrar en conflicto con una funci&oacute;n com&uacute;n (porque el parser de PHP falla si hay un <span style="font-family: 'courier new', courier;">NUL</span> en el archivo, en alg&uacute;n lado).</li>
<li style="text-align: justify;">Declarar una funci&oacute;n llamada <span style="font-family: 'courier new', courier;">__lambda_func</span> romper&aacute; <span style="font-family: 'courier new', courier;">create_function</span> -- la implementaci&oacute;n real es llamar a <span style="font-family: 'courier new', courier;">eval</span>, crear la funci&oacute;n llamada <span style="font-family: 'courier new', courier;">__lambda_func</span>, e internamente renombrarla al nombre roto. Si <span style="font-family: 'courier new', courier;">__lamda_func</span> ya existe, la primera parte arrojar&aacute; un error fatal.</li>
</ul>
<h4>Otros</h4>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">Incrementar (<span style="font-family: 'courier new', courier;">++</span>) un <span style="font-family: 'courier new', courier;">NULL</span> produce <span style="font-family: 'courier new', courier;">1</span>. Decrementar (<span style="font-family: 'courier new', courier;">--</span>) un <span style="font-family: 'courier new', courier;">NULL</span> produce <span style="font-family: 'courier new', courier;">NULL</span>. Decrementar una cadena de la misma forma la deja sin cambios.</span></li>
<li style="text-align: justify;">No hay generadores.</li>
</ul>
<h3>Framework web</h3>
<h4>Ejecuci&oacute;n</h4>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">Un &uacute;nico archivo <span style="font-family: 'courier new', courier;">php.ini</span> compartido controla partes&nbsp;<em>masivas</em> de la funcionalidad de PHP e introduce reglas complejas respecto de qu&eacute; se antepone a qu&eacute; y cu&aacute;ndo. El software PHP que espera ser instalado en m&aacute;quinas arbitrarias tiene que reescribir configuraciones de todos modos para normalizar su entorno, lo que derrota en mayor parte el uso de un mecanismo como php.ini de todos modos.</span>
<ul>
<li>PHP busca a <span style="font-family: 'courier new', courier;">php.ini</span> en varios lugares, por lo que puede (o puede que no) ser posible que se anteponga al de tu host. S&oacute;lo&nbsp;<em>un</em> archivo de esos ser&aacute; parseado, sin embargo, por lo que no puedes sobreescribir un par de configuraciones y terminar ah&iacute;.</li>
</ul>
</li>
<li style="text-align: justify;">PHP b&aacute;sicamente corre como CGI. Cada vez que una p&aacute;gina es alcanzada, PHP recompila toda la cosa antes de ejecutarse. Incluso los frameworks de juguete de servidores de Python no act&uacute;an as&iacute;.<br />
Esto ha llevado a un mercado completo de "aceleradores de PHP" que s&oacute;lo compilan una vez, acelerando PHP hasta el nivel de cualquier otro lenguaje. Zend, la compa&ntilde;&iacute;a detr&aacute;s de PHP, ha hecho esto parte de su <a href="http://www.zend.com/products/server/">modelo de negocios</a>.</li>
<li style="text-align: justify;">Por un tiempo algo largo, los errores PHP iban al cliente por defecto -- supongo que para ayudar durante el desarrollo. No creo que esto siga siendo verdad, pero todav&iacute;a veo el error de mysql siendo escupido al principio de alguna p&aacute;gina.</li>
<li style="text-align: justify;">PHP est&aacute; lleno de extra&ntilde;os "huevos de pascua", como <a href="http://phpsadness.com/sad/11">producir el logo de PHP con el argumento correcto</a>. No s&oacute;lo es esto completamente irrelevante a construir&nbsp;<em>tu</em> aplicaci&oacute;n, sino que permite a cualquiera detectar si est&aacute;s usando PHP (y quiz&aacute; incluso estimar aproximadamente la versi&oacute;n), a pesar de cu&aacute;ntas configuraciones <span style="font-family: 'courier new', courier;">mod_rewrite</span>, FastCGI, proxy inverso o <span style="font-family: 'courier new', courier;">Server:</span> tengas.</li>
<li style="text-align: justify;">Las l&iacute;neas en blanco antes o despu&eacute;s de los tags <span style="font-family: 'courier new', courier;"><?php ... ?></span>, incluso en librer&iacute;as, cuentan como texto literal y es interpolado en la respuesta (o causa errores de "cabeceras ya enviadas"). Tus opciones son o estrictamente evitar l&iacute;neas extras al final de cada archivo (el siguiente luego de <span style="font-family: 'courier new', courier;">?></span> no cuenta), o simplemente evitar el token de cerrado <span style="font-family: 'courier new', courier;">?></span>.</li>
</ul>
<h4>Implantanci&oacute;n</h4>
<p style="text-align: justify;">La implantaci&oacute;n por lo general se cita como una de las mayores ventajas de PHP: copiar algunos archivos y listo. En verdad, eso es mucho m&aacute;s f&aacute;cil que correr un proceso completo como puede que tengas que hacer en Python, Ruby o Perl. Pero PHP deja mucho que desear.</p>
<p style="text-align: justify;">En todas partes estoy en favor de correr las aplicaciones web como servidores de aplicaci&oacute;n y hacer proxies reversos a ellos. Toma un esfuerzo m&iacute;nimo configurar esto y los beneficios son muchos: puedes manjar tu servidor web y tu aplicaci&oacute;n separadamente, puedes correr tantos o tan pocos procesos de la aplicaci&oacute;n en tantas m&aacute;quinas como quieras sin necesitar m&aacute;s servidores web, puedes correr la aplicaci&oacute;n con un usuario diferente con cero esfuerzo, puedes cambiar de servidores web, puedes bajar la aplicaci&oacute;n sin tocar el servidor web, puedes hacer implantaci&oacute;n continua solo cambiando unos puntos fifo, etc. Malear tu aplicaci&oacute;n a tu servidor web es absurdo y no hay una buena raz&oacute;n para hacerlo m&aacute;s.</p>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">PHP est&aacute; naturalmente atado a Apache. Correrlo separadamente, o con cualquier otro web server requiere igual de trabajo (posiblemente m&aacute;s) que implantar cualquier otro lenguaje.</span></li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">php.ini</span> se aplica a cada aplicaci&oacute;n en cualquier lugar. Hay un &uacute;nico archivo <span style="font-family: 'courier new', courier;">php.ini</span>, y aplica globalmente; si est&aacute;s en un server compartido y necesitas cambiarlo, o si corres dos aplicaciones que necesitan configuraciones distintas, no tuviste suerte; tienes que aplicar la uni&oacute;n de todas las configuraciones y diferenciarlas desde dentro de las aplicaciones mismas usando <span style="font-family: 'courier new', courier;">init_set</span> o en el archvio de configuraci&oacute;n de Apache o en .htaccess. Si puedes. Tambi&eacute;n wow, hay un mont&oacute;n de lugares que necesitas checkear para darte cuenta de c&oacute;mo una configuraci&oacute;n est&aacute; obteniendo su valor.</li>
<li style="text-align: justify;">Similarmente, no hay forma de "aislar" una aplicaci&oacute;n PHP y sus dependencias del resto del sistema. &iquest;Correr dos aplicaciones que requieren diferentes versiones de una librer&iacute;a, o incluso de PHP mismo? Comienza construyendo una segunda copia de Apache.</li>
<li style="text-align: justify;">La aproximaci&oacute;n de "un mont&oacute;n de archivos", aparte de hacer el ruteo un gran dolor de trasero, tambi&eacute;n significa que debes cuidadosamente abilitar o deshabilitar lo que est&aacute; de hecho visible, porque tu jerarqu&iacute;a de URLs es tambi&eacute;n tu &aacute;rbol de c&oacute;digo entero. Los archivos de configuraci&oacute;n otros "parciales" necesitan guardas C-simil para prevenir que sean cargados directamente. El ruido de control de versiones (e.g., <span style="font-family: 'courier new', courier;">.svn</span>) necesita protecci&oacute;n. Con mod_php, <em>todo</em> en tu sistema es un punto potencial de entrada; con un servidor de aplicaci&oacute;n, hay un s&oacute;lo punto de entrada y la &uacute;nica URL controla si es invocada.</li>
<li style="text-align: justify;">No puedes hacer una actualizaci&oacute;n continua de un mont&oacute;n de archivos que corren estilo-CGI, a menos que quieras crashes y comportamiento indefinido a medida que los usuarios llegan a tu sitio a medio camino de la actualizaci&oacute;n.</li>
<li style="text-align: justify;">A pesar de lo "simple" que es de configurar Apache para que corra PHP, hay trampas sutiles incluso ah&iacute;. Mientras la documentaci&oacute;n de PHP sugiere usar <span style="font-family: 'courier new', courier;">SetHandler</span> para hacer que los archivos .php corran como PHP, <span style="font-family: 'courier new', courier;">AddHandler</span> parece funcionar igual de bien, y de hecho Google me da el doble de resultados para &eacute;l. Aqu&iacute; est&aacute; el problema.<br />
Cuando usas <span style="font-family: 'courier new', courier;">AddHandler</span>, le est&aacute;s diciendo a Apache que "ejecutar esto como php" es&nbsp;<em>una posible&nbsp;</em>forma de ejecutar archivos .php. &iexcl;<strong>Pero</strong>! Apache no tiene la misma idea de las extensiones de archivos que cualquier otro humano en el planeta tiene. Est&aacute; dise&ntilde;ado para soportar, digamos, <span style="font-family: 'courier new', courier;">index.html.en</span> siendo reconocido ambos como ingl&eacute;s y como HTML. Para apache, un archivo puede tener&nbsp;<em>cualquier n&uacute;mero</em> de extensiones simult&aacute;neamente.<br />
Imagina que tienes un formulario de subida de archivos en un directorio p&uacute;blico. Para asegurarte que nadie suba archivos php, solo verificas que no tengan una extensi&oacute;n <span style="font-family: 'courier new', courier;">.php</span>. Todo lo que un atacante tiene que hacer es subir un archivo llamado <span style="font-family: 'courier new', courier;">foo.php.txt</span>; tu formulario no ver&aacute; el problema, pero Apache <em>lo reconocer&aacute;</em> como PHP y lo ejecutar&aacute; alegremente.<br />
El problema aqu&iacute; no es "usar el nombre de archivo original" o "no validar mejor", el problema es que tu servidor web est&aacute; configurado para correr cualquier c&oacute;digo con el que se encuentre -- precisamente la misma propiedades que hace a PHP "f&aacute;cil de implantar". CGI requer&iacute;a, <span style="font-family: 'courier new', courier;">+x</span>, que era&nbsp;<em>algo</em>, pero PHP ni siquiera eso. Y esto no es un problema te&oacute;rico; he encontrado muchos sitios actuales con este problema.</li>
</ul>
<h4>Caracter&iacute;sticas faltantes</h4>
<p style="text-align: justify;">Considero todas estas ser de distinto nivel de cr&iacute;tico para construir una aplicaci&oacute;n web. Parece razonable que PHP, con su mayor punto de venta siendo que es un "lenguaje web", deber&iacute;a tener algunas de ellas.</p>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;">No hay sistema de templates. Est&aacute; PHP en s&iacute; mismo, pero nada que funcione como un gran interpolador m&aacute;s que un programa.</span></li>
<li style="text-align: justify;">No hay filtros de XSS. No, "recuerda usar <span style="font-family: 'courier new', courier;">htmlspecialchars</span>" no es un filtro XSS. <a href="https://pypi.python.org/pypi/MarkupSafe">Esto es</a>.</li>
<li style="text-align: justify;">No hay protecci&oacute;n CSRF. Te toca hacerlo a t&iacute;.</li>
<li style="text-align: justify;">No hay API est&aacute;ndar de base de datos. Cosas como PDO tienen que envolver cada llamada individual a la API para abstraer las diferencias.</li>
<li style="text-align: justify;">No hay ruteo. Tu website se ve exactamente igual que tu sistema de archivos. Muchos desarrolladores han sido enga&ntilde;ados en pensar que <span style="font-family: 'courier new', courier;">mod_rewrite</span> (y <span style="font-family: 'courier new', courier;">.htaccess</span> en general) es un sustituto aceptable.</li>
<li style="text-align: justify;">No hay autenticaci&oacute;n o autorizaci&oacute;n.</li>
<li style="text-align: justify;">No hay servidor de desarrollo. ("Arreglado" en 5.4. Llev&oacute; a la vulnerabilidad de <span style="font-family: 'courier new', courier;">Content-Length</span> de m&aacute;s abajo. Tambi&eacute;n, tienes que portar todas tus reglas de rewrite a una cosa que envuelve PHP, porque no hay ruteo.)</li>
<li style="text-align: justify;">No hay debugging interactivo.</li>
<li style="text-align: justify;">No hay un mecahismo de implantaci&oacute;n coherente; s&oacute;lo "copiar todos estos archivos al servidor".</li>
</ul>
<h3>Seguridad</h3>
<h4>L&iacute;mites del lenguaje</h4>
<p style="text-align: justify;">La reputaci&oacute;n de seguridad pobre de PHP es en mayor parte porque toda datos arbitrarios de un lenguaje y los tira en otro. Esto es mala idea. <span style="font-family: 'courier new', courier;">"<script>"</span> puede no significar nada en SQL, pero ciertamente lo hace en HTML.</p>
<p style="text-align: justify;">Haciendo esto peor est&aacute; el grito com&uacute;n por "sanitizar tus entradas". Esto est&aacute; completamente <em>equivocado</em>; no puedes mover una varita m&aacute;gica para hacer que un mont&oacute;n de datos est&eacute;n inherentemente "limpios". Lo que necesitas es hablar el lenguaje: usar placeholders con SQL, usar listas de argumentos cuando se generan procesos, etc.</p>
<ul style="text-align: justify;">
<li>PHP completamente <em>alienta</em> el "sanitizado": hay una <a href="http://www.php.net/manual/en/book.filter.php">extensi&oacute;n de filtrado de datos</a> entera para hacer eso.</li>
<li>Todos los <span style="font-family: 'courier new', courier;">addslashes</span>, <span style="font-family: 'courier new', courier;">stripslashes</span> y otros sinsentidos relacionados-a-slashes son distracciones que no ayudan en nada.</li>
<li>No hay, hasta lo que puedo decir, una forma segura de instanciar un proceso. S&Oacute;LO puedes ejecutarlo a trav&eacute;s de una cadena por la l&iacute;nea de comandos. Tus opciones son escapar como loco y esperar que la l&iacute;nea de comandos por defecto use el escapado correcto, o <span style="font-family: 'courier new', courier;">pcntl_fork</span> y <span style="font-family: 'courier new', courier;">pcntl_exec</span> <em>manualmente</em>.</li>
<li>Ambos <span style="font-family: 'courier new', courier;">escapeshellcmd</span> y <span style="font-family: 'courier new', courier;">escapeshellarg</span> existen con descripciones vagamente similares. Noten que en Windows, <span style="font-family: 'courier new', courier;">escapeshellarg</span> no funciona (porque asume sem&aacute;ntica de la l&iacute;nea de comandos Bourne) y <span style="font-family: 'courier new', courier;">escapeshellcmd</span> s&oacute;lo reemplaza un mont&oacute;n de puntuaci&oacute;n con espacios porque nadie puede entender c&oacute;mo funciona el escapado de comandos de Windows (que puede silenciosamente romper todo lo que est&eacute;s intentando hacer).</li>
<li>Los bindeos originales incorporados para MySQL, todav&iacute;a ampliamente usados, no tienen forma de crear instrucciones preparadas.</li>
</ul>
<p style="text-align: justify;">Al d&iacute;a de hoy, <a href="http://www.php.net/manual/en/security.database.sql-injection.php">la documentaci&oacute;n de PHP sobre inyecci&oacute;n SQL</a> recomienda pr&aacute;cticas locas como checkeo de tipos, usando <span style="font-family: 'courier new', courier;">sprintf</span> y <span style="font-family: 'courier new', courier;">is_numeric</span>, manualmente usando <span style="font-family: 'courier new', courier;">mysql_real_escape_string</span> en todos lados, o manualmente usar <span style="font-family: 'courier new', courier;">addslashes</span> en todos lados (que &iexcl;"puede ser &uacute;til"!). No hay menci&oacute;n de PDO o parametrizaci&oacute;n, excepto en los comentarios de los usuarios. Me quej&eacute; de este hecho espec&iacute;ficamente a <em>un desarrollador de PHP</em> al menos hace dos a&ntilde;os, estaba alarmado, y la p&aacute;gina nunca cambi&oacute;.</p>
<h4>Inseguro-por-defecto</h4>
<ul>
<li style="text-align: justify;"><span style="line-height: 13px;"><span style="font-family: 'courier new', courier;">register_globals</span>. Est&aacute; desactivado por defecto desde hace un tiempo ya, y se fue en 5.4. No me importa. Es una <em>verg&uuml;enza</em>.</span></li>
<li style="text-align: justify;"><span style="font-family: 'courier new', courier;">include</span> aceptando URLs HTTP. Igual.</li>
<li style="text-align: justify;">Comillas m&aacute;gicas. Tan cerca a seguro-por-defecto y a&uacute;n as&iacute; tan lejos de comprender el concepto totalmente. E, igual.</li>
<li style="text-align: justify;">Puedes, digamos, <a href="http://www.idontplaydarts.com/2011/02/scanning-the-internal-network-using-simplexml/">escanear una red</a> usando el soporte XML de PHP, y abusando su soporte ubicuo de nombres-de-archivos-como-URLs. S&oacute;lo <span style="font-family: 'courier new', courier;">libxml_disable_entity_loader()</span> puede arreglar esto, y el problema s&oacute;lo est&aacute; mencionado en los comentarios del manual.</li>
</ul>
<h4>N&uacute;cleo</h4>
<p style="text-align: justify;">El int&eacute;rprete de PHP mismo ha tenido algunos problemas de seguridad&nbsp;<em>fascinantes</em><em>.</em></p>
<ul style="text-align: justify;">
<li><span style="line-height: 13px;">En 2007 el int&eacute;rprete tuvo una vulnerabilidad de desbordamiento de enteros. El arreglo comenz&oacute; con if (size > INT_MAX) return NULL; y se fue <a href="http://use.perl.org/use.perl.org/_Aristotle/journal/33448.html">en picada desde all&iacute;</a>. (Para aquellos que no est&eacute;n c&oacute;modos con el C: <span style="font-family: 'courier new', courier;">INT_MAX</span> es el mayor entero que entrar&aacute; en una variable, nunca. Espero que puedan darse cuenta del resto desde ah&iacute;.)</span></li>
<li>M&aacute;s recientemente, PHP 5.3.7 se las arregl&oacute; para incluir una funci&oacute;n crypt() que permitir&iacute;a, en efecto, a <a href="https://bugs.php.net/bug.php?id=55439">cualquiera loggearse sin un password</a>.</li>
<li>El servidor de desarrollo de PHP 5.4 es vulnerable a una denegaci&oacute;n de servicio, porque toma el header <span style="font-family: 'courier new', courier;">Content-Length</span> (que cualquiera puede setear a cualquier cosa) y trata de alocar eso en memoria. <a href="http://www.exploit-db.com/exploits/18665/">Esto es una mala idea</a>.</li>
</ul>
<p style="text-align: justify;">Podr&iacute;a seguir desenterrando m&aacute;s, pero el punto no es que hay X exploits -- el software siempre tiene bugs, pasa, no importa. La <em>naturaleza</em> de estos es horripilante. Y no me puse a buscar estos; s&oacute;lo aparecieron en mi puerta en los &uacute;ltimos meses.</p>
<hr style="width: 75%;" width="75%" />
<h2>Conclusi&oacute;n</h2>
<p style="text-align: justify;">Alg&uacute;n comentarista ha correctamente se&ntilde;alado que no tengo una conclusi&oacute;n. Y, bueno, no tengo una conclusi&oacute;n. Si llegaste hasta aqu&iacute;, asumo que estabas de acuerdo conmigo antes de haber comenzado. :)</p>
<p style="text-align: justify;">Si s&oacute;lo sabes PHP y est&aacute;s curioso de aprender algo m&aacute;s, dale un intento al <a href="http://docs.python.org/2/tutorial/">tutorial de Python</a> y trata con <a href="http://flask.pocoo.org/">Flask</a> para la parte web. (No soy un fan&aacute;tico de su lenguaje de templates, pero cumple con su trabajo.) Desarma las piezas de tu aplicaci&oacute;n, pero son a&uacute;n las mismas piezas y deber&iacute;an ser lo suficientemente familiares. Podr&iacute;a escribir un post real sobre esto m&aacute;s tarde; una intrducci&oacute;n remolino a un lenguaje entero y tecnolog&iacute;as web no pertenece aqu&iacute; abajo.</p>
<p style="text-align: justify;">M&aacute;s tarde o para projectos m&aacute;s grandes podr&iacute;as querer <a href="http://www.pylonsproject.org/">Pyramid</a>, que es nivel-medio, o <a href="https://www.djangoproject.com/">Django</a>, que es una monstruosidad compleja que trabaja muy bien para construir sitios como el de Django.</p>
<p style="text-align: justify;">Si no eres un desarrollador para nada pero a&uacute;n leiste esto por alguna raz&oacute;n, no estar&eacute; feliz hasta que cualquiera en el planeta haya pasado por <a href="http://learnpythonthehardway.org/">Aprender Python de la Manera Dif&iacute;cil</a>, as&iacute; que ve a hacer eso.</p>
<p style="text-align: justify;">Est&aacute; tambi&eacute;n Ruby on Rails y algunos competidores que no he usado nunca, y Perl sigue vivo y coleando con Catalyst. Lee cosas, aprende cosas, construye cosas, vu&eacute;lvete loco.</p>
<h2>Cr&eacute;ditos</h2>
<p style="text-align: justify;">Gracias a los siguientes por la inspiraci&oacute;n:</p>
<ul style="text-align: justify;">
<li><a href="http://alokmenghrajani.github.io/wtf/php.html"><span style="line-height: 13px;">PHP Turtles</span></a></li>
<li><a href="http://phpsadness.com/">PHP Sadness</a></li>
<li><a href="http://www.phpwtf.org/">PHP WTF</a></li>
<li><a href="https://wiki.theory.org/YourLanguageSucks#PHP_sucks_because%3A">YourLanguageSucks</a></li>
<li><a href="http://tnx.nl/php.html">PHP in contrast to Perl</a></li>
<li><a href="http://two-pi-r.livejournal.com/622760.html">La densa, furiosa e inspiracional bronca de Pi</a></li>
<li><a href="http://tracks.ranea.org/post/13908062333/php-is-not-an-acceptable-cobol">PHP is not an acceptable COBOL</a></li>
<li><a href="http://www.php.net/manual/en/index.php">La documentaci&oacute;n PHP</a></li>
<li>un mont&oacute;n de fan&aacute;ticos y contra-fan&aacute;ticos PHP</li>
<li>y, por supuesto, Rasmus Lerdorf por su salvaje mala interpretaci&oacute;n de la mayor&iacute;a de Perl</li>
</ul>
<p style="text-align: justify;">H&aacute;ganme saber si tienen adiciones, o si estoy (&iexcl;con hechos!) equivocado sobre algo.</p>
