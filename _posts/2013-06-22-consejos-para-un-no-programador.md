---
layout: post
status: publish
published: true
title: Consejos para un no-programador
author:
  display_name: Alpha
  login: Alpha
  email: alphagma@gmail.com
  url: http://www.alphasmanifesto.com/
author_login: Alpha
author_email: alphagma@gmail.com
author_url: http://www.alphasmanifesto.com/
wordpress_id: 4888
wordpress_url: http://blog.alphasmanifesto.com/?p=4888
date: '2013-06-22 21:18:32 +0000'
date_gmt: '2013-06-23 02:18:32 +0000'
categories:
- Technology
tags:
- proyecto
- automatizaci&oacute;n
- flexibilidad
- requerimientos
- organizaci&oacute;n
- habilidades
- sistema
- work
- software
- an&aacute;lisis
- consejos
- procesos
- problemas
- team work
- conocimiento
- programming
comments:
- id: 9021
  author: Geo
  author_email: lady_pop@hotmail.com
  author_url: ''
  date: '2013-06-23 09:43:56 +0000'
  date_gmt: '2013-06-23 14:43:56 +0000'
  content: Me voy a volver changa antes de hacer funcionar un solo boton! jaja gracias
    por los consejos te quiero!
- id: 16302
  author: Lo que no se sabe que no se sabe | Alpha&#039;s Manifesto
  author_email: ''
  author_url: http://blog.alphasmanifesto.com/2014/07/27/lo-que-no-se-sabe-que-no-se-sabe/
  date: '2014-07-27 11:14:48 +0000'
  date_gmt: '2014-07-27 16:14:48 +0000'
  content: "[&#8230;] de la programaci&oacute;n, pero sobre aspectos que no ten&iacute;an
    que ver con la tecnolog&iacute;a. (&#8220;Consejos para un no-programador&#8220;).
    Hoy, uno de esos conceptos volvi&oacute; a mi recargado, y quisiera elaborar sobre
    &eacute;l: no saber [&#8230;]"
- id: 27233
  author: How to find the problem &#8211; Alpha&#039;s Manifesto
  author_email: ''
  author_url: http://blog.alphasmanifesto.com/2016/01/12/how-to-find-the-problem/
  date: '2016-01-12 22:36:12 +0000'
  date_gmt: '2016-01-13 04:36:12 +0000'
  content: "[&#8230;] while ago I made a post about knowledge management (&#8220;Consejos
    para un no-programador&#8220;, Advice for a non-developer, Spanish only for now).
    I mentioned that it is important to have [&#8230;]"
---
O "c√≥mo no perderse en este bosque"

<p style="text-align: justify;">Una amiga m&iacute;a me coment&oacute; que quer&iacute;a comenzar a programar, y de alguna forma lo entend&iacute; impl&iacute;citamente como un buen momento para dar consejos de orientaci&oacute;n. No es por sonar arrogante, pero sabemos que la programaci&oacute;n puede ser una tarea desafiante, y me pregunt&eacute; cu&aacute;les ser&iacute;an los mejores consejos para alguien que est&aacute; empezando.</p>
<p style="text-align: justify;"><!--more--></p>
<p style="text-align: justify;">Curioso para la situaci&oacute;n: no s&eacute; qu&eacute; tipo de lenguaje va a estar aprendiendo, no s&eacute; en qu&eacute; entorno o tipos de aplicaciones va a estar programando,. Tampoco s&eacute; cu&aacute;les son los est&aacute;ndares de calidad a los que tiene que someterse, ni qu&eacute; proceso seguir&aacute;, ni qu&eacute; tama&ntilde;o tienen los proyectos que quiere perseguir. Por supuesto, los consejos variar&iacute;an mucho si cada una de estas variables cambiara, pero a&uacute;n as&iacute; pens&eacute; que ten&iacute;a consejos para dar, independientemente del contexto.</p>
<p style="text-align: justify;">Y es parte de lo que hago, tanto por gusto como por trabajo. Participo en proyectos peque&ntilde;os, de una persona y sin procesos (como es <a href="https://github.com/AlphaGit/alphasmanifesto">Alpha's Manifesto</a>, el theme de este blog que hago en ratos libres). Tambi&eacute;n participo en proyectos peque&ntilde;os colaborativos y con procesos m&aacute;s definidos, como <a href="https://github.com/CommonJobs/CommonJobs">CommonJobs</a>, y a la vez participo de proyectos m&aacute;s grandes, con docenas de desarrolladores, procesos rigurosos y distintos problemas ocurriendo todos los d&iacute;as (no hay ejemplos p&uacute;blicos esta vez, lo lamento). Algo aprend&iacute; de esa variabilidad.</p>
<p style="text-align: justify;">Creo que hay ciertas habilidades que un buen desarrollador puede <em>desarrollar</em> (pun intended), que lo hacen claramente superior, independientemente de las variables que antes mencion&eacute;.</p>
<p style="text-align: justify;">Esta fue mi respuesta, sobre la cual elaborar&eacute; m&aacute;s abajo:</p>
<blockquote><p>Lo &uacute;nico que te aconsejo de antemano es:</p>
<ul>
<li>s&eacute; muy organizada, es lo &uacute;nico que te va a salvar cuando la memoria de alg&uacute;n detalle te falle</li>
<li>las soluciones los problemas deben sentirse elegantes y no espec&iacute;ficas. Como si pudieras resumir en pocos pasos que resuelven muchos problemas juntos. Si est&aacute;s peleando con muchos casos particulares, hay algo de tu aproximaci&oacute;n al problema que puede estar mal.</li>
<li>Diferenci&aacute; muy bien y con criterio riguros&iacute;simo:
<ol>
<li>lo que sab&eacute;s con seguridad,</li>
<li>lo que cre&eacute;s que sea cierto,</li>
<li>lo que ignor&aacute;s -- tener eso claro hace muy met&oacute;dico el proceso de descubrir la causa de un problema que no entend&eacute;s. (Y mucha gente no sabe hacerlo!)</li>
</ol>
</li>
</ul>
</blockquote>
<h2 style="text-align: justify;">Organizaci&oacute;n</h2>
<p style="text-align: justify;">Lo primero que menciono es la organizaci&oacute;n que uno debe tener. Claramente, en muchas disciplinas distintas uno debe ser organizado, y en&nbsp;<em>cualquier</em> disciplina sirve ser organizado. &iquest;Cu&aacute;l es la novedad aqu&iacute;?</p>
<p style="text-align: justify;"><strong>El desarrollo de software es una de esas tareas que puede crecer exponencialmente en complejidad</strong> que uno debe batallar mentalmente. Como hablaba con <a href="http://mravinale.wordpress.com/">Mariano Ravinale</a>, crear software es como crear grandes castillos en las nubes. El cliente puede pedirnos una funcionalidad simple, clara y directa (&iexcl;que no siempre es el caso!), y eso puede requerir que tomemos decisiones muy espec&iacute;ficas y demasiado t&eacute;cnicas, sin olvidar el impacto de todas las posibles elecciones. Si el cliente quiere que su aplicaci&oacute;n sea de color rojo, pensamos qu&eacute; tecnolog&iacute;a permitir&aacute; que eso se vea de la mejor manera en todas las plataformas de destino, sin necesidad de repetir c&oacute;digo. Pensamos en un m&oacute;dulo que le permitir&aacute; al usuario configurarlo (esto es una discusi&oacute;n aparte: flexibilidad vs. esfuerzo) y pensamos en cu&aacute;ntos m&oacute;dulos distintos depender&aacute;n de la decisi&oacute;n.</p>
<p style="text-align: justify;">Puede que el cliente quiera guardar un dato y editarlo luego, y pensamos en m&eacute;todos de persistencia, en m&oacute;dulos de datos vs. m&oacute;dulos de presentaci&oacute;n, c&oacute;mo se acoplan y c&oacute;mo deber&iacute;an ser independientes, en la coordinaci&oacute;n de la l&oacute;gica entre ellos, en la separaci&oacute;n de responsabilidades y todas las capas involucradas... Claramente, esto puede ser un caos sin organizaci&oacute;n.</p>
<p style="text-align: justify;"><strong>La organizaci&oacute;n propia, de la forma que sea, es la que nos permitir&aacute; tener un mapa mental </strong>del proceso a seguir, o de los pasos a verificar. Hay muchos tipos de organizaci&oacute;n y no todos son exclusivos de los dem&aacute;s. Organizar el tiempo propio es una cosa (por ejemplo, <a href="https://blog.alphasmanifesto.com/2012/01/20/como-uso-trello-para-trabajar/">mi flujo personal con Trello</a>). Organizar el proyecto es otra cosa, y la disciplina completa del an&aacute;lisis y el planeamiento (top-down, bottom-up, agile, risk management, waterfall, issue tracking, etc.). Organizar los archivos f&iacute;sicos del proyecto es otra cosa m&aacute;s, y separar al sistema en componentes es algo m&aacute;s tambi&eacute;n (arquitectura, dise&ntilde;o).</p>
<p style="text-align: justify;">Nuestra memoria no es perfecta y pasados algunos meses, olvidaremos por qu&eacute; algo se hizo de alguna forma, cu&aacute;nto tiempo toma, o qu&eacute; tan dif&iacute;cil era. La organizaci&oacute;n no es la respuesta, pero es la herramienta que nos acerca a ella. Es tambi&eacute;n la herramienta que permite a varias personas trabajar en un mismo proyecto sin que se pisen los talones una a otra.</p>
<p style="text-align: justify;">La conclusi&oacute;n es: la organizaci&oacute;n es imprescindible.</p>
<h2 style="text-align: justify;">Elegancia en las soluciones</h2>
<p style="text-align: justify;">El segundo punto que mencion&eacute; se refiere a la&nbsp;<em>elegancia</em> de las soluciones que encontremos. Esto no es s&oacute;lo para saciar un gusto personal de c&oacute;digo ingenioso (que s&iacute;, tambi&eacute;n lo es), sino por un principio m&aacute;s general.<span style="text-decoration: underline;"><br />
</span></p>
<p style="text-align: justify;">La programaci&oacute;n de software surgi&oacute; como una herramienta para automatizar tareas repetitivas. M&aacute;s a&uacute;n, evolucion&oacute; r&aacute;pido y permiti&oacute; automatizar soluciones a&nbsp;<em>tipos</em> de problemas, y no a problemas espec&iacute;ficamente. Cuando <a href="http://en.wikipedia.org/wiki/Charles_Babbage">Charles Babbage</a> dise&ntilde;&oacute; su m&aacute;quina calculadora, no era para dar el resultado de la suma de los n&uacute;meros que &eacute;l necesitaba, sino para cualquier suma de n&uacute;meros que pudieran presentarse.</p>
<p style="text-align: justify;">Bajo ese mismo concepto, el software desarrollado puede resolver un tipo de problemas m&aacute;s amplio o m&aacute;s espec&iacute;fico. Esta caracter&iacute;stica es la que se denomina&nbsp;<em>flexibilidad</em> de un software: mientras a m&aacute;s situaciones distintas pueda un software adaptarse, se dir&aacute; que es m&aacute;s flexible. Por supuesto que la flexibilidad tiene su costo (&iexcl;nada es gratis!) y resolver problemas m&aacute;s gen&eacute;ricos involucra un esfuerzo mayor. Volviendo al ejemplo, la m&aacute;quina de Babbage no era un procesador de textos, que vino mucho tiempo despu&eacute;s.</p>
<p style="text-align: justify;">En el d&iacute;a al d&iacute;a del desarrollo, planteamos soluciones a problemas y muchas veces vamos a corregir soluciones para casos espec&iacute;ficos que no cumplieron con nuestro resultado esperado. Si nuestro programa calcula la divisi&oacute;n entre dos n&uacute;meros, nos encontraremos con que falla al dividir por cero. Encontraremos que falla si la precisi&oacute;n de ambos n&uacute;meros es demasiado distinta y no podremos dar un resultado demasiado preciso. Encontraremos que determinados resultados no pueden representarse en el tipo de datos que hemos elegido (siempre ocurrir&aacute; esto: la memoria no es infinita). Encontraremos que operaciones consecuentes propagan un determinado margen de error. Si todo esto ocurre para una simple divisi&oacute;n, &iexcl;imaginen el software complejo!</p>
<p style="text-align: justify;"><strong>Si nuestro c&oacute;digo busca resolver cada situaci&oacute;n particular de una forma distinta, estamos haciendo algo mal.</strong> Estamos dejando que la complejidad del c&oacute;digo se dispare terriblemente por un poco m&aacute;s de flexibilidad, y no siempre vale la pena. Para procesos m&aacute;s complejos, estamos permitiendo que el riesgo de errores sea mucho mayor, y estamos haciendo m&aacute;s dif&iacute;cil de entender a alguien m&aacute;s qu&eacute; es lo que el c&oacute;digo intenta resolver. Esto es, el famoso&nbsp;<em><a href="http://en.wikipedia.org/wiki/Spaghetti_code">c&oacute;digo spaghetti</a></em>, entre otros.</p>
<p style="text-align: justify;">Formas de resolver esto hay muchas, varias de ellas relacionadas al planeamiento, planteo de prioridades y decisiones arquitecturales o de dise&ntilde;o, divide &amp; conquer, etc. Pero para alguien que programa, la clave es esta: si lo que est&aacute;s haciendo se siente innecesariamente complicado, quiz&aacute; est&eacute;s tomando la aproximaci&oacute;n equivocada al problema.</p>
<h2 style="text-align: justify;">Manejo del conocimiento</h2>
<p style="text-align: justify;">Est&aacute; claro para cualquier desarrollador con experiencia que no sabe todo lo que est&aacute; pasando. A veces son dudas sobre la tecnolog&iacute;a, a veces es desconocimiento de las reglas del proyecto en el que est&aacute;. Pero saber <em>qu&eacute; es lo que uno sabe</em> y <em>qu&eacute; es lo que uno no sabe</em> marca una diferencia.</p>
<p style="text-align: justify;">Cualquier desarrollador se encontrar&aacute; tambi&eacute;n resolviendo problemas inesperados, cosas que ocurren sin una clara explicaci&oacute;n para &eacute;l. La forma de encontrar esas causas es aplicar un m&eacute;todo riguroso de poner a prueba el conocimiento que tenemos.</p>
<p style="text-align: justify;"><strong>Es importante clasificar lo que conocemos</strong> o esperamos que sea verdad en una de las siguientes categor&iacute;as:</p>
<p style="text-align: justify;"><strong>Lo que es cierto</strong>, son aquellas verdades que hemos comprobado o que indefectiblemente no deber&iacute;an cambiar. Cosas como que 1 + 1 = 2, que tenemos suficiente disco para la operaci&oacute;n que estamos realizando, que nuestro procesador funciona bien, que el requerimiento a resolver es el correcto. Este es el tipo de cosas que debemos tomar como base para encontrar la soluci&oacute;n a nuestro problema, y aunque siempre hay un "pero", es cierto tambi&eacute;n que si dudamos de absolutamente todo, caemos en una crisis existencial y dejamos de existir. As&iacute; no se resuelve nada.</p>
<p style="text-align: justify;"><strong>Lo que creemos que es cierto</strong>, con cierto nivel de confianza. Este es el tipo de hechos que dimos por asumido pero que no hemos verificado personalmente, y que dependiendo de c&oacute;mo hayamos llegado a creerlo, el nivel de confianza que le daremos. Cosas como que la versi&oacute;n del software que estamos usando para desarrollar no tiene bugs (con un bajo nivel de confianza si es una versi&oacute;n beta, por ejemplo), o que los efectos de las instrucciones que estamos ejecutando son realmente los esperados.</p>
<p style="text-align: justify;">Hoy por hoy me encuentro trabajando en resolver unos problemas de pruebas en Selenium, y sin tener un vistazo a lo interno del framework, aqu&iacute; es donde hago suposiciones y las pongo a prueba -- todo mi conocimiento al respecto est&aacute; formando su nivel de confianza y esa red de conocimiento evoluciona sin necesidad que yo me ponga a leer un libro por una semana, o el c&oacute;digo fuente durante un mes. Aplicando el m&eacute;todo cient&iacute;fico de hip&oacute;tesis, experimento y re-planteo es una forma f&aacute;cil de llegar a soluciones r&aacute;pido, pero debemos saber distinguir el nivel de credibilidad de cada una de nuestras afirmaciones.</p>
<p style="text-align: justify;"><strong>Lo que ignoramos</strong>. Suena tonto, pero no lo es. Es importante saber encuadrar cu&aacute;les son las cosas que ignoramos. Sabiendo que nuestro conocimiento sobre un tema es limitado, podemos haber escuchado al respecto de otras cosas fuera de ese l&iacute;mite, y es importante recordar que est&aacute;n ah&iacute; y las ignoramos. Cuando el conocimiento que tenemos no es suficiente para resolver un problema, la soluci&oacute;n est&aacute; claramente en una de estas &aacute;reas y no haberlas identificado significa que simplemente no sabremos c&oacute;mo proseguir.</p>
<h2 style="text-align: justify;">&iquest;Y ustedes?</h2>
<p style="text-align: justify;">&iquest;Qu&eacute; consejos le dar&iacute;an a alguien que va a comenzar en programaci&oacute;n? O mejor a&uacute;n: &iquest;qu&eacute; consejo le dar&iacute;an a alguien que est&aacute; por comenzar en lo que ustedes hacen? &iquest;Hay cualidades que pueden practicarse o aprenderse sin necesidad de entrar en tecnicismos de la disciplina?</p>
<h2 style="text-align: justify;">Update 2013-07-01: Salir de la Zona de Confort</h2>
<p style="text-align: justify;">Agradezco a <a href="https://twitter.com/noeliasfranco">Noelia Franco</a> qui&eacute;n, tras leer el art&iacute;culo, propuso lo siguiente:</p>
<blockquote>
<p style="text-align: justify;">Algo que siempre le digo tmb a mis alumnos es nunca quedarse en la "zona de confort". Es decir, esto lo se hacer as&iacute;, siempre funciona y no aprendo nada nuevo total esto anda. Siempre hay que estar abierto a nuevas propuestas y sobre todo no tener miedo al cambio, algo que es tan habitual en nuestra profesi&oacute;n.</p>
</blockquote>
<p style="text-align: justify;">Estoy muy de acuerdo y creo que tambi&eacute;n es de las habilidades b&aacute;sicas a aprender: saber mejorar. Esto es importante no s&oacute;lo por el s&oacute;lo hecho de mejorar, sino porque esta es una disciplina que est&aacute; constantemente en cambio. Siempre surgen nuevas formas de resolver problemas, nuevas tendencias, y con ellos nuevos problemas. Ser un novato en algo y pensar que es suficiente es una sentencia de muerte. Ser un experto en algo y pensar que es suficiente es otra sentencia de muerte, aunque m&aacute;s prolongada. Siempre hay que aprender, siempre hay que cuestionarse si se puede mejorar lo que uno conoce, siempre se debe investigar sobre cosas nuevas.</p>
